{"meta":{"title":"咔斯の小窝","subtitle":"Kasi's Hiding Place","description":"","author":"咔斯Sama","url":"https://www.kassama.top","root":"/"},"pages":[{"title":"关于咔斯！","date":"2022-04-07T17:49:56.000Z","updated":"2022-07-18T13:21:28.170Z","comments":true,"path":"about.html","permalink":"https://www.kassama.top/about.html","excerpt":"","text":"先来首音乐吧！ 阁下问我是谁？我的常用名为：咔斯Sama 英文名为：Kass 笔名为：咔斯阁下要记好哦！以下是我最常用的头像！呼呼！我的斑Sama太帅了！！！(痴汉笑) Blog经历 2020年02月11日 - 第一次成功搭建并公布博客的诞生！（当时采用的Wordpress） 2020年03月08日 - 博客服务器更换为了阿里云（2020/4/9：就是恶心到我了，才不打算续费了） 2020年04月04日 - 博客入驻了第一个友链！但是现在我已经和那位友人关系破裂了 2020年04月17日 - 我的Q群游戏宠物养成RE爆肝成功并发布！ 2021年04月23日 - 宠物养成RE 更新日志集合发布！ 2022年04月08日 - 其他的就不说啦！今天正式把Wordpress博客从蜡姬阿里芸搬到了Hexo博客的Github Pages！啥也不说！开心诶嘿嘿！ 怎么联系我呢！ 实时聊天：博客右下角的实时聊天来进行深入♂交流哦！ 邮箱联系：&#107;&#x61;&#x73;&#x73;&#115;&#x61;&#109;&#97;&#x40;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#x6d; ！ 企鹅联系：点击我跳转至QQ 如无法跳转请手动添加：1347993953！ 其它内容 网站大部分文章符合开源协议,可在非盈利用途下自由转载,复制,但对文章本身内容请勿在转载过程中断章取义,改写文章原本的表达含义,转载请注明引用来源,尊重原作者的创作成果;对于标记为”禁止转载”等文章,属于个人文章,不属于技术类,不具备广泛的传播性,文章本身具有针对性内容,这类文章不可转载.请悉知。 关于您的用户隐私数据声明:本网站无登录注册功能,且该网站属于无后端开发,所有界面均是静态html,网站本身不会以任何理由收集存储您的用户数据,但部分服务插件可能需要这些这些数据用于功能完整性支持,且这些信息均匿名化.评论的数据存储能力由第三方平台leancloud提供,即时通讯聊天服务的数据存储由第三方平台daocloud提供;天气插件会获取您的位置信息,该服务由和风天气提供;具体相关的隐私策略和数据使用规范可以点击上述链接了解;如果您不了解或不希望这些平台使用您的信息,可以选择不评论,不点击即时聊天功能,禁止浏览器授权本网站获取位置信息 网站主题元素说明:网站中所使用的动漫元素是”蕾姆”,版权归MF library J所有,本网站所使用相关元素仅用于美化装扮,没有用作任何盈利性内容,如果对该网站所使用的主题元素存疑,可以通过邮件联系沟通.且该网站定制化主题完全免费开源,您可以点击这里获取该定制主题的源代码进行自由修改,增删内容,并转化为属于自己的定制主题 评论功能的使用情况说明:评论功能依托于Valine提供的相关服务,评论功能对所有访问者全面开放状态,请勿发布广告灌水等信息,规范发言. 本博客是基于糖羽仙在Github上发布的Hexo主题进行二次开发的。"},{"title":"咔斯的朋友们哦！！","date":"2013-07-13T12:46:25.000Z","updated":"2022-09-07T06:38:02.493Z","comments":true,"path":"friend.html","permalink":"https://www.kassama.top/friend.html","excerpt":"","text":"记忆是一种相聚的方式，放下是一种自由的形式。 不悲伤，不忧愁，邂后回忆都是美好的故事。 咔斯的好朋友们！"},{"title":"文章归档","date":"2022-04-07T11:48:08.524Z","updated":"2022-04-07T11:48:08.524Z","comments":true,"path":"archives.html","permalink":"https://www.kassama.top/archives.html","excerpt":"","text":""},{"title":"咔斯の相册","date":"2022-09-06T09:10:14.000Z","updated":"2022-09-07T03:35:07.859Z","comments":true,"path":"photos.html","permalink":"https://www.kassama.top/photos.html","excerpt":"呐呐！香香甜甜的蕾姆酱！(&#x2F;≧▽≦)&#x2F;","text":"呐呐！香香甜甜的蕾姆酱！(&#x2F;≧▽≦)&#x2F; 图片来源自网络，如果侵犯了您的权益，请及时联系我哦！联系QQ: 1347993953"}],"posts":[{"title":"蕾姆酱美图瀑布流","slug":"瀑布流","date":"2022-07-25T12:32:08.000Z","updated":"2022-09-17T14:52:58.342Z","comments":true,"path":"/pbl.html","link":"","permalink":"https://www.kassama.top/pbl.html","excerpt":"呐呐！香香甜甜的蕾姆酱！(&#x2F;≧▽≦)&#x2F;自己写的初版，留个纪念qwq","text":"呐呐！香香甜甜的蕾姆酱！(&#x2F;≧▽≦)&#x2F;自己写的初版，留个纪念qwq #RemApp{ transition: all .3s ease-in; } .box{ position: relative; transition: all .3s ease-in; margin: 0 auto; } #RemApp .box .imgbox{ width: 260px; height: auto; /* float: left; */ display: inline-block; vertical-align: top; margin: 5px 5px; border-radius: 10px; box-shadow: 3px 3px 5px #999; transition: all .3s ease-in; vertical-align: top; } #RemApp .box .imgbox .content .ksImg{ width: 100%; border-radius: 10px; } 图片来源自网络，如果侵犯了您的权益，请及时联系我哦！联系QQ: 1347993953","categories":[{"name":"web笔记","slug":"web笔记","permalink":"https://www.kassama.top/categories/web%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.kassama.top/tags/web/"},{"name":"HTML","slug":"HTML","permalink":"https://www.kassama.top/tags/HTML/"}]},{"title":"JsDelivr缓存问题","slug":"JsDelivr缓存问题","date":"2022-04-08T02:38:37.000Z","updated":"2022-07-18T11:50:27.667Z","comments":true,"path":"/code-1.html","link":"","permalink":"https://www.kassama.top/code-1.html","excerpt":"备忘！JsDelivr缓存不刷新怎么办！","text":"备忘！JsDelivr缓存不刷新怎么办！ 今天修改图片，Push到仓库后图片一直不刷新，然后就去查了一下，为了以防万一还是自己记下来比较好！想要刷新缓存的时候可以通过访问一个 url 实现：就是将cdn 改成 purge举个例子吧！ https://cdn.jsdelivr.net/gh/kasisama/Blog_images@main/background/Rem.png 改为 https://purge.jsdelivr.net/gh/kasisama/Blog_images@main/background/Rem.png 即可 重新访问一下网址查看刷新是否成功！","categories":[{"name":"日志","slug":"日志","permalink":"https://www.kassama.top/categories/%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"CDN","slug":"CDN","permalink":"https://www.kassama.top/tags/CDN/"}]},{"title":"你好！屏幕前的用户！","slug":"你好世界！","date":"2022-04-07T16:42:32.000Z","updated":"2022-07-18T13:09:34.534Z","comments":true,"path":"2022/04/08/你好世界！/","link":"","permalink":"https://www.kassama.top/2022/04/08/%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C%EF%BC%81/","excerpt":"欢迎来到咔斯Samaの小窝！","text":"欢迎来到咔斯Samaの小窝！ 欢迎你呀！嘻嘻，咔斯的博客正式迁移辣！2022.4.8日，因服务器和域名到期，原博客地址www.kasisama.top迁移至www.ksmmhy.xyz","categories":[{"name":"日志","slug":"日志","permalink":"https://www.kassama.top/categories/%E6%97%A5%E5%BF%97/"}],"tags":[]},{"title":"仙玉尘缘-指令集合大全","slug":"仙玉尘缘-指令集合大全","date":"2022-02-14T12:11:12.000Z","updated":"2022-04-08T08:01:04.670Z","comments":true,"path":"2022/02/14/仙玉尘缘-指令集合大全/","link":"","permalink":"https://www.kassama.top/2022/02/14/%E4%BB%99%E7%8E%89%E5%B0%98%E7%BC%98-%E6%8C%87%E4%BB%A4%E9%9B%86%E5%90%88%E5%A4%A7%E5%85%A8/","excerpt":"使用指令在这里！","text":"使用指令在这里！ 基础功能指令注册+昵称#性别 注册一个游戏账户（每个QQ号只能注册一个） 种族信息 查看当前的种族信息 属性 查看当前的人物属性 信息 查看当前人物信息 钱包 查看当前货币数量 位置 查看当前所在地图 背包 查看我的背包物品 签到 每天签到一次 闭关 开始闭关修炼 出关 结束闭关修炼 突破 突破境界（游戏内属于境界制，没有等级制，你可以把突破理解为升级） 商店 查看当前所在地图上的商店 购买+物品 购买当前地图上商店内的物品 购买+物品*数量 购买当前地图上商店内的物品（多个数量购买） 使用+物品 使用背包内的物品 使用+物品*数量 使用背包内的物品（多个数量使用） 查询+物品名 查询指定物品 查询+怪物名 查询指定怪物 对话+NPC名称 和当前地图上的指定NPC对话 XX+排行榜 此功能需要自行配置【排行榜配置.ini】文件 加入队伍+队伍ID 加入一支队伍（需队员未满员） 开启自动战斗 开启自动战斗（开启后，每次打怪的战斗都会自动计算结果，不可使用功法） 关闭自动战斗 关闭自动战斗（关闭后，每次打怪的战斗都需要手动发送攻击，可使用功法） 本源 查看自己已经感悟的本源 感悟本源 感悟本源，随机获得本源 活动功能指令异界战场 查看当前异界战场活动的参与数据 世界BOSS 查看当前降临的世界BOSS 世界攻击 攻击世界BOSS 世界攻击+功法名 攻击世界BOSS，使用功法 任务功能指令主线任务 查看当前主线剧情任务 支线任务 查看当前随机的支线任务 完成主线 完成主线剧情任务 完成支线 完成随机支线任务 地图功能指令界域 查看游戏内的所有界域 传送+界域名 传送进入指定的界域内（消耗传送时间） 地图 查看当前所在界域内的所有地图 进入+地图名 进入指定的地图（需在当前界域内） 战斗功能指令探索 在当前位置探索怪物（可能遇到机缘） 攻击 攻击探索遇到的怪物 攻击+功法名 使用功法攻击遇到的怪物 沙盒功能指令采集 在当前地图上采集草药 垂钓 在当前地图上钓取鱼类 挖矿 在当前地图上挖取矿石 收货 结束采集、垂钓、挖矿 炼丹炼器功能指令丹方 查看可炼制的丹药的丹方 器谱 查看可炼制的器材的器谱 炼丹+丹药名 炼制指定的丹药 炼器+器材名 炼制指定的器材 收丹 收取当前炼制的丹药 凝器 凝炼当前炼制的器材 升级炼丹 升级炼丹等级 升级炼器 升级炼器等级 炼丹状态 查看当前炼丹的状态 炼器状态 查看当前炼器的状态 邮箱功能指令邮箱 查看我的邮箱 阅读+邮件ID 阅读指定的邮件 收件+邮件ID 收取指定的邮件 删件+邮件ID 删除指定的邮件 组队功能指令队伍列表 查看所有队伍信息 创建队伍 创建一支队伍 解散队伍 解散一支队伍（需是队长） 退出队伍 退出当前队伍（需是队员） 查看队伍 查看当前所在队伍 功法功能指令我的功法 查看自己已经学习的功法 查看功法+功法名 查看指定的功法信息 法宝功能指令法宝 查看当前祭出的法宝信息 收回 收回当前已经祭出的法宝 法宝背包 查看我的法宝背包内的法宝 查询+法宝名 查询指定法宝（支持查询其他人的法宝） 强化+法宝名#强化材料 强化法宝背包内的法宝（优先扣除专属强化材料） 精炼+法宝名#精炼材料 精炼法宝背包内的法宝（优先扣除专属精炼材料） 预强化+法宝名#强化材料 预先查看强化法宝数据 预精炼+法宝名#精炼材料 预先查看精炼法宝数据 客服功能指令充值货币1+QQ#数量 客服充值指令 充值货币2+QQ#数量 客服充值指令 充值货币3+QQ#数量 客服充值指令 充值货币4+QQ#数量 客服充值指令 充值物品+QQ#物品名*数量 客服充值指令 © 版权声明 文章版权归微香社区所有，未经允许请勿转载，谢谢~ THE END","categories":[{"name":"wiki","slug":"wiki","permalink":"https://www.kassama.top/categories/wiki/"}],"tags":[{"name":"wiki","slug":"wiki","permalink":"https://www.kassama.top/tags/wiki/"}]},{"title":"宠物养成RE 更新日志集合","slug":"宠物养成re-更新日志集合","date":"2021-04-23T14:32:59.000Z","updated":"2022-07-18T13:12:18.678Z","comments":true,"path":"/petupdata.html","link":"","permalink":"https://www.kassama.top/petupdata.html","excerpt":"插件下载更新地址：城通网盘 （访问密码：6725）","text":"插件下载更新地址：城通网盘 （访问密码：6725） 2.3.5.4 2022.7.1 [修复]宠物学习、锻炼、健身等加成和最终效果错乱 [修复]宠物打工如果打工状态为空，将按照一个固定值进行奖励 [修复]控制台广告不显示 [修复]无饱食也可以宠物打工 [修复]交易无法添加物品及显示错乱 [适配]宠物交易在开启货币对接的情况下已可以使用 [新增]控制台发放奖励的通知信息会在每次成功发放奖励后保存通知信息 2.3.5.3 2022.4.20 [新增]自动更新！！！ [优化]控制台玩家数据搜索功能强化 [优化]控制台玩家数据适配对接后的货币 [优化]排行消息排版 [修复]无法完成健身的bug [修复]排行显示错误的bug 2.3.5.2 2022.4.19 [修复]宠物银行无法转账bug [修复]打开礼包时如果没有填数量就会崩溃 [修复]商店购买物品全是好感 2.3.5.1 2022.4.19 [新增]宠物加成系统，在宠物配置那里设置 [重构]宠物打工时将大幅扣除心情 [修复]宠物对接银行失效的问题 [修复]宠物进化时属性显示错误 [优化]优化 查看宠物 消息 [删除]宠物签到点赞 2.3.5 2022.3.26 修复所有bug 打工支持自定义 新增宠物管理拓展 2.3.3.3 2022.3.6 修复紧急bug 修复控制台闪退bug 控制台优化 修复宠物使用会导致崩溃的bug 修复宠物猜拳口令失效 修复开箱后所需物品不消失的bug 新增物品属性禁止交易，开启后物品无法交易 2.3.2 2022.2.27 修复控制台拓展显示 修复频道支持拓展的问题 修复领养宠物不能翻页 修复宠物健身无响应 修复好感商店扣钱和显示问题 修复群开关发放奖励bug 新增单次购买上限(限制单次批量购买的数量，如果数量较大就可能会出现错误，建议10~30以内) 2.3.1 2022.2.25 修复控制台错误分支bug 修复宠物银行bug 任何状态都可使用宠物商店 宠物进化觉醒清空成长改为减去成长 新增频道支持【拓展功能，目前只限小栗子框架】 新增家族神树属性自定义，【老用户请前往 控制台-互动-杂项 填写神树相关的设置，新用户用自带数据即可】 新增宠物进化觉醒需要好感限制【老用户请前往控制台填写进化好感，新用户用自带数据即可】 新增好感商店【老用户请前往 指令配置.ini里添加一个好感商店的指令，具体格式见公告尾】 新增新手积累七天签到奖励【老用户可下载最新数据包，单独提取出[新手签到配置.ini]文件安装】 注： 【重要】宠物进化觉醒需要好感限制，必须要配置，否则会出错（新用户请忽略） 【重要】好感商店指令的格式为：（老用户不配置将无法使用好感商店） [好感商店] 指令&#x3D;好感商店 2.3 2022.2.8 重置整体框架 删除宠物逃跑功能 删除宠物重生道具 拓展授权方式已改为买断制，之前购买过的授权可以继续在老版本使用 UI重做 支持指令自定义（老版本升级，请把2.3压缩包里的“指令配置.ini”解压到数据目录） 优化部分控制台功能，提高体验 修复所有已知bug，同时重置后的初期几个版本可能不太稳定，需要大家帮助寻找bug，感谢大家的支持 老版本升级如果遇到图片失效的情况，请检查数据目录里的图片文件夹，新版本将图片文件夹“宠物养成”改为了“图片” 2.2.9 2021.10.27 修复宠物时间系统 修复整体稳定性 修复宠物找回 2.2.8 2021.08.30 修复所有已知bug 宠物银行拓展发布，请加群进行下载。 2.2.7 2021.08.29 修复所有已知bug 2.2.6 2021.08.28 修复所有已知bug 控制台优化 2.2.5 2021.08.10 修复所有已知bug 重置交易系统 2.2.3 2021.06.22 修复所有已知bug 新增控制台数据热更新（不用再频繁点击数据重载） 2.2 2021.04.23 修复所有已知bug 重构整个游戏基层 新增放生宠物 新增发放补偿 单个宠物的打工、健身、学习、散步图片 控制台重塑，优化体验 宠物打工、健身支持图片 修复宠物锻炼完成后数据出错的问题 2.1.5.6 2020.08.25 修复创建家族崩溃bug 修复进化觉醒饱食bug 修复攻击自己的bug 新增宠物饱食上限属性 新增指令：查看宠物＋宠物名 控制台新增点赞机器人QQ，请前往配置 2.1.5.5 2020.08.9 修复数组崩溃问题 正式采用新分群机制 修复艾特失效问题 优化插件整体 2.1.5 2020.06.14 修复宠物状态bug 修复宠物家族bug 修复学习限制bug 修复商店购买礼包bug 修复打开随机礼包bug 新增宠物进化分支 新增宠物健身 2.1.4 2020.06.03 修复查看商品bug 修复一些状态bug 新增家族列表(指令) 新增家族成员(指令) 控制台玩家配置新增玩家QQ搜索 控制台物品配置新增快捷添加至商店 注：新增的两个指令需要在【屏蔽消息前缀】里添加上，不添加需要加上前缀使用 2.1.3 2020.05.27 修复重启拓展停用bug 修复创建家族崩溃bug 修复接受交易货币bug 2.1.2 2020.05.18 优化DLC用户的体验 修复所有已知BUG 2.1.1 2020.05.14 修复宠物登录问题 修复拓展刷新问题 2.1.0 2020.05.14 修复无法创建家族bug 修复宠物散步成长bug 开发DLC，欢迎各位玩家和开发者 2.0.9 2020.05.8 修复宠物打工bug 优化控制台日志 2.0.8 2020.05.6 修复对接货币失效bug 修复宠物交易导致崩溃bug 新增物品获取类型，请自行前往控制台配置 2.0.7 2020.05.5 修复货币bug 修复宠物打工控制台bug 即将开放DLC，玩家可自己制作DLC 2.0.6 2020.05.4 修复新增货币对接导致的bug 优化摸头、学习、锻炼 新增成长类型的物品 新增宠物打工 2.0.5 2020.05.4 修复神树果实无法批量使用bug 修复重复领养宠物bug 修复重复领养宠物bug 新增货币对接 新增宠物交易 修复宠物抽奖抽到货币bug 优化控制台编辑框显示 2.0.4 2020.04.29 修复宠物偷袭bug 神树果实已可使用 我的宠物显示宠物种类 修复批量使用礼包时只获得一次奖励bug 2.0.3 2020.04.27 修复错误饱食心情扣除间隔bug 修改宠物治疗无濒死状态时也可使用 检测更新替换为自动更新 2.0.2 2020.04.27 修复宠物逃跑后无法找回bug 控制台新增饱食心情扣除间隔选项 控制台新增防御的物品类型 2.0.1 2020.04.26 修复宠物偷袭血量扣空依然可活动bug 修改宠物饥饿后仍可使用部分指令 控制台新增宠物钓鱼上钩几率 修复不会定时扣饱食度bug 修复检测更新bug 2.0.0 2020.04.25 修复宠物偷袭bug 修复宠物改名bug 控制台新增删除玩家 1.1.9 2020.04.22 不忘初心，重新启动 具体功能请自行体验 1.1.8 2019.04.13 重写后因BUG过多已经下架。","categories":[{"name":"日志","slug":"日志","permalink":"https://www.kassama.top/categories/%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"宠物养成","slug":"宠物养成","permalink":"https://www.kassama.top/tags/%E5%AE%A0%E7%89%A9%E5%85%BB%E6%88%90/"}]},{"title":"Vuem面试题整理","slug":"Vuem面试题整理","date":"2021-02-15T10:47:53.000Z","updated":"2022-09-19T15:27:46.443Z","comments":true,"path":"/webNotes-VueInterview.html","link":"","permalink":"https://www.kassama.top/webNotes-VueInterview.html","excerpt":"Vue面试题，转载的qwq","text":"Vue面试题，转载的qwq 一. 说几个vue中的指令和它的用法？v-model 双向数据绑定；v-for 循环；v-if, v-show 显示与隐藏；v-bind 动态绑定属性v-on 事件绑定；v-once 只绑定一次。 二. v-on指令可以同时监听多个函数吗?可以, v-on的事件监听类似于DOM原生api添加事件监听者addEventListenerv-on 可以给一个事件同时绑定多个函数，也可以一次绑定多个事件v-bind 可以一次绑定多个属性，使用v-bind=&#123;&#125;结构来实现 三. vue中v-if和v-show有什么区别v-if 的原理是根据判断条件来动态的进行增删DOM元素, 比较耗费性能和内存, 频繁显示隐藏不建议使用v-show 是根据判断条件来动态的进行显示和隐藏元素, 通过设置样式display为block和none来实现, 适用于频繁显示隐藏的情况 四. vue循环中为什么使用key?需要使用key来给循环中每个节点做一个唯一标识，要保证一个循环中key的值各不相同, 以避免vue中的重用机制造成可能的渲染异常. 从底层来看, key属性主要为了Diff算法就可以正确的识别此节点。并高效的更新虚拟DOM。 五. vue中数据绑定是怎么实现的？双向绑定指令v-model的本质是什么？Vue组件data中的数据在组件创建时，都会被Object.defineProperty改造为set,get类型的属性，当数据发生变化时set方法就会调用，set方法中添加了重新渲染的代码。v-model相当于 v-bind:value 加 v-on:input 六. 分别简述computed和watch的使用场景 computed: 当一个属性受多个属性影响的时候就需要用到computed 例子： 购物车商品结算的时候 watch: 当一条数据影响多条数据的时候就需要用watch 例子：搜索数据 七. 列举一下Vue组件生命周期函数，什么时候需要在destroyed中写代码？beforeCreate createdbeforeMount mountedbeforeUpdate updatedbeforeDestroy destroyed当前页面有事件监听器或者计时器时,需要在destroyed中取消或销毁 八. vue的组件配置对象中都有哪些常用字段？分别是什么作用？Data 组件中的数据props 组建的属性数据,接收父组件的传值computed 计算属性components 定义或引用子组件methods 自定义函数watch 属性监听filters 数据过滤器mounted 等生命周期函数 九. &lt;keep-alive&gt;&lt;&#x2F;keep-alive&gt;的作用是什么?keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。 十. vue组件中如何获取dom元素?使用ref属性获取, 在组件模板元素中添加ref属性, 在js中用this.$refs获取 十一. Vue.nextTick()方法有什么作用？当vue中动态数据修改时,会导致界面的更新,而界面的更新属于异步更新, 当打印界面数据时, 异步更新尚未完成, 所以打印结果是更新之前的数据Vue.nextTick表示异步更新函数, 其参数是更新完成的回调函数 十二. 如何让CSS只在当前组件中起作用(vue中如何实现样式隔离)？在组件中的style前面加上scoped, 如果父子组件都有样式隔离, 则父组件中无法修改子组件样式, 此时可用样式穿透修改vue2: 父组件选择器&gt;&gt;&gt;子组件选择器{子组件样式}vue3: :deep(子组件选择器) 十三. vue中如何处理跨域请求vue中处理跨域请求一般要设置代理服务器实现跨域,在vue项目的根目录中的vue.config.js配置文件,在devServer字段中配置服务器代理在使用axios请求数据时直接使用代理地址 十四. axios和ajax的区别：axios是通过promise实现对ajax技术的一种封装，就像jQuery实现ajax封装一样。简单来说： ajax技术实现了网页的局部数据刷新，axios实现了对ajax的封装。 十五. vue中有哪些数据传递方式? 组件传值: 父传子,通过props属性或slot插槽传递, 子传父,通过$emit发射自定义事件传递, 非父子,通过bus总线传递 路由传值: 可通过url路径传值和编程式导航对象传值 vuex状态管理传值 十六. vue中路由如何传值? 使用url拼接字符串的形式传值 使用$route.query接收 使用友好URL传值 使用$route.params接收 使用命名路由params字段传值 使用$route.params接收 使用query对象传值 使用$route.query接收 十七. vue组件中如何监听路由?在组件的watch监听器中对$route这个字段进行监听全局监听路由在app.vue组件中,watch监听$route可以监听全局路由也可以在全局路由守卫beforeEach函数中操作全局路由 十八. vue路由的钩子函数有哪些?全局的路由钩子函数：beforeEach、afterEach单个的路由钩子函数：beforeEnter组件内的路由钩子函数：beforeRouteEnter、beforeRouteLeave、beforeRouteUpdate 十九. 介绍以下vue组件内的路由守卫(即路由的生命周期&#x2F;钩子函数)，有哪些参数（to，from，next）vue组件中的路由钩子方法有beforeRouteEnter 进入路由前调用。这里组件还未创建, 不能使用thisbeforeRouteUpdate 路由更新之前被调用, 组件不会重新初始化, 可以使用thisbeforeRouteLeave 离开路由之前被调用，可以访问里面的this属性方法中都有三个参数:to :即将要进入的目标路由对象；from :当前导航即将要离开的路由对象；next ：调用该方法后，才能进入下一个路由钩子函数 二十. vue中怎么实现非父子组件之间的传值？在项目规模不是特别大时，可以创建一个空组件作为总线，项目中其他组件都可以通过总线进行传值。大大型项目中，可以使用vuex进行数据管理，将数据统一放在store中进行管理。也可以在路由跳转时,通过路由传值 二十一. vue中如何实现父子组件间的双向数据绑定?Vue中父子组件双向绑定利用父子组件传值原理,父组件向子组件传值, 通过给子组件定义value属性来接收传值子组件向父组件传值, 通过子组件$emit发射名为input的自定义事件在父组件中使用子组件标签时, 在子组件标签上通过v-model绑定父组件数据,实现父子组件的双向绑定 二十二. vuex如何使用?首先在项目中 npm install vuex 安装新建vuex状态管理文件,导入vuex并添加状态数据在组件中使用mapState()函数映射状态数据并使用在组件中使用commit()函数提交申请修改状态数据 二十三. Vuex的核心概念有哪些？组件如何使用store中的数据如何改变store中的数据？state &#x3D;&gt; 基本数据 在组件中使用mapState()函数把状态数据映射入组件即可使用getters &#x3D;&gt; 从基本数据派生的数据 我们在组件中使用 $store.getters获取数据mutations &#x3D;&gt; 提交更改数据的方法，同步！ 我们在组件中使用 $store.commit(&#39;&#39;,params)修改数据actions &#x3D;&gt; 像一个装饰器，包裹mutations，使之可以异步。 使用mapAction()映射入组件使用modules &#x3D;&gt; 模块化Vuex 二十四. vue有哪些常用的UI组件库element (PC端)，VUX (移动端),Mint UI(移动端)Vant (移动端) 二十五. vue有哪些优缺点:优点: 简单好用： Vue.js包含基于HTML的标准模板，可以更轻松地使用和修改现有应用程序。 单页面应用, 使用单文件组件结构, 用户体验好, 性能比较好：相比其他框架, 它占用更少的空间，并提供更好的性能。 基于MVVM模式, 数据驱动视图, 更高效 适应性强：组件化设计可以提高开发效率,方便代码复用, 提升整个项目的可维护性缺点: vue生态环境不如react和angular, 但有追赶和超越的趋势 vue2不支持IE8 vue3 不支持IE10 vue封装的比较深入,不利于seo优化, 报错不明显 二十六. 什么是MVVM?MVVM是model-view-viewModel的简写, 它是一种开发模式, 它实现了视图和数据逻辑之间的分离, model模型指的是后端传递的数据, view视图指的是所看到的页面, viewModel是连接视图view和模型model的桥梁, 从而实现模型model到视图view的转化 和 视图view到模型model的转化, 也就是我们所说的双向数据绑定, 使用MVVM模式实现的前端框架有 vue 和 react 二十七. vue项目怎么打包app ? 首先使用 webpack 打发布包, npm run build 然后通过 Hbuilder 新建H5+App项目 把第一步打包出的dist文件夹导入项目 在项目中的manifest.json文件中进行打包配置 点击Hbuilder工具菜单栏发行中的 原生App-云打包 二十八. vue中虚拟DOM的实现原理虚拟DOM是通过js对象的结构来记录html标签节点, 当组件数据更新需要渲染视图时,先用diff算法计算变化前后js对象(也就是虚拟DOM树)结构的不同, 得到最小差异, 然后针对性的更新部分真实DOM节点, 这样可以极大提高视图渲染效率, 节省内存消耗 二十九. 请说下封装 vue 组件的过程？ 建立组件的模板，先把架子搭起来，写写样式，考虑好组件的基本逻辑。(思考1小时，码码10分钟，程序猿的准则。) 准备好组件的数据输入。即分析好逻辑，定好 props 里面的数据、类型。 准备好组件的数据输出。即根据组件逻辑，做好要暴露出来的方法。 封装完毕了，直接调用即可 三十. 在vue项目中使用组件库, 如何修改组件库中组件的样式?一般vue组件style会添加scoped属性,产生组件样式隔离, 无法直接修改子组件样式此时可以使用vue提供的样式穿透语法修改子组件样式 (父组件选择器 &gt;&gt;&gt; 子组件选择器 vue3是 :deep()) 三十一. vue项目中如何使用sass? 下载安装sass模块 npm install sass --save 在组件的style标签上添加lang=”scss” 32. SCSS&#x2F;less相比于CSS有哪些优势？在css语法基础上添加了编程能力，使之具有定义变量，嵌套，计算，使用函数,混合等功能 33. scss和less有哪些不同？ 编译环境不同 sass-loader less-loader scss变量使用$定义 ,less变量使用@定义 sass支持条件语句,可以使用if() else() for(), less不支持 34. vue单文件组件如何实现SEO优化(了解)？ 使用预渲染插件prerender-spa-plugin,来执行打包,可以把项目中的每一个页面打包成一个网页，之后可单独实现SEO优化 使用后端模板化渲染页面,也叫SSR服务器渲染 使用Nuxt.js插件执行静态化打包 使用Phantomjs无头浏览器(只有浏览器内核,没有界面) 35. vue3相比于vue2有哪些区别？ vue2使用时直接导入vue构造函数,vue3使用时通过对象解构方式按需导入 vue3中新增了setup函数，数据的定义，更新计算，监听等都在setup函数中执行 setup函数中的数据都需要return导出才能在组件模板中调用 Setup中this为空,可以有效避免this指向修改带来的问题 Vue中的生命周期也在setup中实现，其中取消了beforeCreata和created,其他的生命周期函数名有更新,如destoryed改成了onUnmounted Vue3中使用ref函数定义值类型数据,使用reactive函数定义引用类型数据 Vue3中的ref, reactive,computed等功能函数都需要从vue中解构导出才能使用 Vue3废弃了filters过滤器,建议使用计算属性 vue3中的样式隔离由 &gt;&gt;&gt; 或 /deep/ 改成了 :deep() vue3可以动态绑定样式, 在style中使用v-bind() 绑定响应数据 36. vue3语法糖&#x2F;setup中如何使用状态管理vuex和 路由 ?从vuex模块中引入 useStore 函数, 调用后得到 状态仓库对象store从vue-router模块中引入 useRoute和useRouter函数,调用useRoute()后得到路由信息对象route, 可用于路由传值和路由监听调用useRouter()后得到路由配置对象router, 可用于路由跳转","categories":[{"name":"web笔记","slug":"web笔记","permalink":"https://www.kassama.top/categories/web%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://www.kassama.top/tags/HTML/"},{"name":"Vue","slug":"Vue","permalink":"https://www.kassama.top/tags/Vue/"}]},{"title":"Vue知识点整理3","slug":"Vue知识点整理3","date":"2021-02-08T14:35:29.000Z","updated":"2022-09-18T11:26:45.784Z","comments":true,"path":"/webNotes-vue3.html","link":"","permalink":"https://www.kassama.top/webNotes-vue3.html","excerpt":"Vue知识点整理3","text":"Vue知识点整理3 vue过度与动画 元素进入的样式： v-enter: 进入的起点 v-enter-active: 进入过程中 v-enter-to: 进入的终点 元素离开的样式： v-leave: 离开的起点 v-leave-active: 离开的过程中 v-leave-to: 离开的终点 使用&lt;transition&gt;包裹要过度的元素，并配置name属性 &lt;transition name=&quot;binge&quot;&gt; &lt;h3 v-if=&quot;bool&quot;&gt;你好！&lt;/h3&gt; &lt;/transition&gt; 若有多个元素需要过度，则需要使用&lt;transition-group&gt;，且每个元素都要指定key值 路由 vue路由的实现原理? a标签href值如果以#开头, 访问时#开头的路径会被拼接到url路径上,且页面不刷新 以#开头的路径地址, 叫做哈希(hash)值 哈希值特点: 哈希值改变时, 页面不会刷新 哈希值不会由ajax请求发给服务器 哈希值变化时,会触发hashChange事件 vue路由的配置步骤 (1)导入vue路由插件 &lt;script src=&quot;vue-router.js&quot;&gt;&lt;/script&gt; (2)在vue模板中添加路由跳转标签 &lt;router-link to=&quot;/home&quot;&gt;主页&lt;/router-link&gt; (3)创建路由分发跳转的组件 Vue.component(&quot;homeCom&quot;, &#123;template: &quot;&lt;h1&gt;这是首页&lt;/h1&gt;&quot;&#125;) (4)创建路由对象,并配置路由信息 new VueRouter(&#123; routes：&#123;path: &quot;/home&quot;, component: Home&#125; &#125;) (5)在vue根组件中注册路由 router (6)根组件模板中,设置路由出口 &lt;router-view&gt;&lt;/router-view&gt; 路由有哪两种跳转方式? 编程式导航跳转 router.push(&#39;/home&#39;) router.push(&#123;path: &quot;/home&quot;&#125;) router.push(&#123;path: &quot;main&quot;&#125;) router.forward() 前进 router.back() 后退 router.go() 可前进可后退 this.$router 和 this.$route 的区别? this.$router 是全局唯一的路由配置对象, 固定不变 this.$route 是当前路由页面对应的路由信息对象, 路由跳转时会更新 vue路由有哪四种传值方式? (1)url拼接键值对传值 router.push(&quot;/home?name=&#39;zs&#39;&quot;) 使用$route.query接收 (2)动态url&#x2F;友好型url传值 router.push(&quot;/home/&quot;) 使用$route.params接收 (3)路径跳转+query对象传值 router.push(&#123;path: &quot;/home&quot;,query: &#123;name: this.name&#125;&#125;) 使用$route.query接收 (4)命名路由+params对象传值 router.push(&#123;name: &quot;main&quot;,params:&#123;name: this.name&#125;&#125;) 使用$route.params接收 注: path路径跳转只可以携带query参数, name路由名跳转可以携带params参数和query参数 vue路由四种传值方式的优缺点对比 四种方式中, 1,2,3方式都是把参数拼到了url路径上, 而第4种方式的params参数没有在路径上拼接(第4种方式的query参数也是在url上拼接的) 在url路径上拼接参数, 好处是: 页面刷新时数据不丢失 , 弊端是: 安全性低,且数据大小限制 第4种方式的params参数 好处: 安全性高,且数据大小无限制, 弊端是: 页面刷新, 数据会丢","categories":[{"name":"web笔记","slug":"web笔记","permalink":"https://www.kassama.top/categories/web%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://www.kassama.top/tags/HTML/"},{"name":"Vue","slug":"Vue","permalink":"https://www.kassama.top/tags/Vue/"}]},{"title":"Vue知识点整理2","slug":"Vue知识点整理2","date":"2021-02-05T15:12:58.000Z","updated":"2022-09-18T06:39:21.961Z","comments":true,"path":"/webNotes-vue2.html","link":"","permalink":"https://www.kassama.top/webNotes-vue2.html","excerpt":"Vue知识点整理2","text":"Vue知识点整理2 本地应用内容绑定，事件绑定v-textv-text：指令的作用是设置标签的内容(textContent)默认写法会替换全部内容，使用差值表达式&#123;&#123;&#125;&#125;可以替换指定内容，内部支持写表达式。 v-htmv-html：指令的作用是设置元素的innerHTML，内容中有html结构会被解析为标签。 v-on基础v-on：指令的作用是为元素绑定事件，事件名不需要写on，指令可以简写为@，绑定的方法定义在methods属性中，方法内部通过this关键字可以访问定义在data中的数据。 显示切换，属性绑定v-showv-show：指令的作用是根据真假切换元素的显示状态，原理是修改元素的display，实现显示隐藏，指令后面的内容，最终都会解析为布尔值，值为true元素显示，值为false元素隐藏，数据改变之后，对应元素的显示状态会同步更新。 v-ifv-if：指令的作用是根据表达式的真假切换元素的显示状态，本质是通过操作dom元素来切换显示状态，表达式的值为true，元素存在于dom树中，为false，从dom树中移除，频繁的切换v-show，反之使用v-if,前者的切换消耗小 v-bindv-bind：指令的作用是为元素绑定属性，完整写法是v-bind:属性名，简写的话可以直接省略v-bind，只保留:属性名，需要动态的增删class建议使用对象的方式 列表循环，表单元素绑定v-forv-for：指令的作用是根据数据生成列表结构，数组经常和v-for结合使用，语法是(item,index)in数据，item和index可以结合其他指令一起使用，数组长度的更新会同步到页面上，是响应式的 v-on补充事件绑定的方法写成函数调用的形式，可以传入自定义参数，定义方法时需要定义形参来接收传入的实参，事件的后面跟上.修饰符可以对事件进行限制，.enter可以限制触发的按键为回车，事件修饰符有多种 v-modelv-model：指令的作用时便捷的设置和获取表单元素的值，绑定的数据会和表单元素值相关联，绑定的数据&lt;——&gt;表单元素的值 生命周期生命周期: 一个vue对象从创建到销毁的整个过程生命周期函数: 也叫生命周期钩子, 是在生命周期过程中主动调用的一些函数 钩子函数vue的钩子函数有四个过程, 对应八个函数 创建过程 beforeCreate 创建前 和 created 创建后 渲染过程 beforeMount 渲染前 和 mounted 渲染后 更新过程 beforeUpdate 更新前 和 updated 更新后 销毁过程 beforeDestroy 销毁前 和 destroyed 销毁后 深度监听常见的三种数据更新,视图不更新的特殊情况 data中的数组通过索引更新数据,但数组长度不变 没有在data中定义的数据更新 data中的对象, 初始化后添加的字段更新 深度监听: 主要针对以上第三种监听不到的情况, 用于监听对象的更新 常用的两种解决方案 强制刷新,适用于所有情况 this.$forceUpdate() $set更新, 使用数组更新 this.$set(arr, index, value) 指令修饰符指令修饰符: 在指令后打点调用的属性字段,用于给指令添加特有功能 .number 用于双向绑定,使表单中的数据自动转化为数字类型 .trim 用于双向绑定, 取出表单输入字符前后空格 .prevent 用于事件绑定,阻止事件默认行为 .stop 用于事件绑定, 阻止事件冒泡 .once 用于事件绑定, 限制事件只能触发一次 .shift 用于键盘事件, 指定那些键会触发事件 .prop 用于属性绑定, 可以把标签的attribute属性改成property属性 .capture 用于事件, 默认事件在冒泡过程执行, 它可以使事件在挖洞过程执行 .self 用于事件, 只能由元素自身触发事件,不能由子元素冒泡触发 .left .right .middle 仅当点击特定的鼠标按钮时会处理执行函数 .lazy 用于双向绑定 输入时不更新数据, 输入完成时更新相当于change事件 vue中的指令修饰符有哪些?常用: trim lazy number stop prevent enter不常用: prop capture self left right middle once 组件什么是组件?当一个页面数据视图异常庞大,里边的数据逻辑非常多, 造成页面复杂臃肿, 不易于阅读,调试,更新, 此时, 我们可以把一个页面拆分开, 把页面中一个个独立的功能模块单独分开,独立实现此模块的模板,样式和逻辑, 分割成的每一个模块 叫做 组件, 这就是组件化编程 也是 vue框架的一个好处 组件化有什么好处?使项目结构清晰, 更容易阅读和维护更新, 每一个组件之间作用域相互隔离, 互不干涉, 类似于前端模块化 如果创建一个组件?根组件: 使用new Vue()创建的vue对象就是vue根组件, 全局唯一全局组件: 使用Vue.component()创建的对象就是全局组件,在所有组件模板中可用局部组件: 在组件的components字段中定义的组件是局部组件,之能在其定义的组件模板中使用 组件如何使用?组件可以认为是自定义标签, 直接当作标签来用即可, 叫做组件标签 组件需要注意的细节?组件模板使用template属性绑定模板字符串或独立模板vue内置组件template模板要求有且仅有一个根元素组件数据data是一个函数,不是对象html标签不支持大写, 如果组件名用驼峰定义, 那么组件标签名应用小写 - 分割 为什么组件中的data是一个函数而不是对象?组件一般不是唯一的,是需要复用的,如果组件中data是个对象, 在复用, 引用的是对象的内存地址,相当于浅拷贝, 结果一个组件数据变化时,另一个组件会受到影响, 所以data是一个函数, 返回一个新的对象, 这样每次调用组件, 都会得到一个新的对象,属于深拷贝, 使各个组件数据相互独立,不影响 传值插槽在组件标签的开始标签和结束标签中写的数据叫插槽数据, 插槽数据默认不会展示到子组件模板中, 可以使用vue内置组件slot, 在子组件模板中展示插槽数据，插槽数据不只是字符串也可以是一段html代码在子组件标签中要插入data动态数据, 数据来源于父组件, 会展示到子组件中, 这种方式叫做: 组件传值 组件传值组件传值: 把一个组件中的数据传入另一个组件中展示 使使用插槽slot把父组件数据传入子组件展示, 叫做插槽传值slot 标签就是插槽, 用于展示组件标签中的数据, 每一个slot标签都会展示一遍数据 props父组件向子组件传值: 在子组件对象的props字段中定义属性：props: [&quot;childCount&quot;] 在子组件标签上绑定自定义属性并赋值：&lt;mycom :child-count=&quot;father&quot;&gt;&lt;/mycom&gt; 在子组件对象或模板中调用自定义属性, 调用方式和data数据相同：&lt;div&gt;子组件: &#123;&#123;child&#125;&#125;&lt;/div&gt; slot插槽传值 和 props属性传值 的异同点?相同点: 都是用于父组件向子组件传值不同点: 插槽数据仅用于模板展示,不能在组件对象中调用和修改, 而props属性传值可以在组件中调用,过滤,监听,计算等操作 emit子组件向父组件传值: 定义一个自定义事件, 使用this.$emit() 发射事件把数据传出去： this.$emit(&quot;myevent&quot;, this.childCount) 在子组件标签上绑定自定义事件, 调用事件函数：&lt;mycom @myevent=&quot;getData&quot;&gt;&lt;/mycom&gt; 在父组件中的事件回调中, 获取数据并赋值：getData(data)&#123;this.father = data&#125; bus总线兄弟组件传值： 在全局作用域创建一个空的vue对象, 称之为bus总线：var bus = new Vue() 在发送数据的组件中, 使用bus总线发起自定义事件, 发送数据：bus.$emit(&quot;event&quot;, this.count) 在接收数据的组件中， 使用bus绑定事件接收数据：bus.$on(&quot;event&quot;, data=&gt;&#123;this.count2 = data&#125;） 自定义指令全局自定义指令：`Vue.directive(&quot;binge&quot;, function(el,obj,c)&#123;&#125;` 参数1：`指令所在的元素`，参数2：`指令名对象` 参数3：`指令配置对象` 定义局部vue指令: 只能在当前vue模板中使用 directives:&#123; color(a,b,c)&#123; console.log(a,b,c) a.style.color = b.value; &#125; &#125; 异步更新由于vue数据的更新是同步的, 更新后数据this.name立即改为最新值但是视图的更新是异步的, 数据更新后, 视图并没有立即更新, 所以打印视图结果还是更新前的结果如果想在视图更新结束后,打印视图的显示, 可以在异步更新回调中执行this.$nextTick(()=&gt;&#123;&#125;)异步更新队列, 参数是视图更新完成的回调函数 监视器watch监视器的监视原理?当vue初始化时,会使用Object.defineProperty()对data数据进行重定义和数据拦截, 在set函数中,判断此属性是否在watch监视器中被监视, 如果是,调用new Watcher创建watcher对象并和此属性进行绑定, 把回调函数传入watch监视器的函数参数中, 当监视的属性发生变化时, 会去执行set函数, 在set函数中调用watcher对象的回调, 也就是watch监视器中的监视函数 (使用原理还是回调原理) 类似于发布订阅模式 重用机制重用机制: 也叫惰性机制, 指vue模板中的结构在销毁重建过程中,如果销毁和重建的标签结构相同, 则不再执行销毁和重建过程, 而是把要销毁的标签修改属性后直接拿来用好处: 可以减少DOM创建销毁, 节省内存, 提高渲染效率弊端: 表单中输入的数据内容没有重置, 可能暴漏隐私信息, 或造成更新渲染异常 那如何解决重用机制弊端, 如何避免重用机制发生? 解决方案1: 使创建销毁前后的标签结构不同, 即可避免重用机制 解决方案2: 给创建销毁前后的标签设置属性key以不同的值, 可以避免重用机制 key属性是给vue模板中元素的唯一标识,可以使vue视图时更加准确的识别每一个DOM元素,提高渲染的效率, 在v-for循环中建议给每一个循环的元素添加不同的属性key值, 以避免重用机制造成的渲染异常 计算属性计算属性是如何缓存数据的?计算属性每次计算完结果, 会把计算结果赋值给一个全局变量, 当数据更新时, vue会判断计算属性依赖的数据源有没有更新,用一个变量dirty(脏值)记录源数据状态, 如果计算属性依赖的源数据没有变化, 会脏值记录为false, 如果有变化, 脏值被记录为true, 之后开始更新视图, 在数据更新到计算属性处, 执行脏值判断, 如果脏值为true,则重新执行计算属性计算过程, 如果脏值为false, 则直接返回全局变量记录的计算结果 Vue基础Vue简介JsvaScript框架简化Dom操作响应式数据驱动官方网址：https://cn.vuejs.org 第一个Vue程序步骤: 导入开发版本Vue.js 创建Vue实例对象，设置el属性和data属性 使用简洁的模板语法把数据渲染到页面上 开发环境版本，包含了有帮助的命令行警告 &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统： --&gt; &lt;div id=&quot;app&quot;&gt; &#123; &#123; message &#125; &#125; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;message: &#x27;Hello Vue!&#x27;&#125; &#125;); &lt;/script&gt; el：挂载点el是用来设置Vue实例挂载（管理）的元素Vue会管理el选项命中的元素及其内部的后代元素可以使用其他选择器，但是建议使用ID选择器可以使用其他的双标签，不能使用HTML和BODY data：数据对象Vue中用到的数据定义在data中data中可以写复杂数据类型的数据渲染复杂类型数据时，遵守js的语法即可","categories":[{"name":"web笔记","slug":"web笔记","permalink":"https://www.kassama.top/categories/web%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://www.kassama.top/tags/HTML/"},{"name":"Vue","slug":"Vue","permalink":"https://www.kassama.top/tags/Vue/"}]},{"title":"Vue知识点整理1","slug":"Vue知识点整理1","date":"2021-02-02T12:24:30.000Z","updated":"2022-09-18T06:38:48.462Z","comments":true,"path":"/webNotes-Vue1.html","link":"","permalink":"https://www.kassama.top/webNotes-Vue1.html","excerpt":"记录一下Vue学习过程","text":"记录一下Vue学习过程 一、Vue基础步骤： 导入开发版本的Vie.js 创建Vue实例对象，设置el属性和data属性 使用简洁的模板语法把数据渲染到页面上 el:挂载点例如：el: &quot;#app&quot; 注意： 不能命中html和body date:数据对象 vue中用到的数据 可以写复杂类型，渲染时遵守js语法 二、本地应用v-text: 设置标签的内容，只会解析为文本 默认写法会替换全部内容，使用插值表达式&#123;&#123;&#125;&#125;可 以替换指定内容 内部支持写表达式 v-html: 设置元素的innerHTML 内容中有Html的结构会被解析为标签 v-on: 为元素绑定事件 事件名不用写on 指令可以简写为@ 绑定方法定义在methods属性中 方法内部可以用this访问data中的数据 事件绑定方法写成函数调用的形式可以传入自定义参数 定义方法时需要定义形参接收传入的实参 事件后.修饰符可以限制事件，如.enter回车 v-show 根据真假切换元素显示状态 原理是修改元素的display 指令后的内容，最终都会解析为布尔值 v-if 根据真假切换元素显示状态 本质是操纵dom元素，表达式为false时从dom树中移除 频繁切换的元素用v-show，反之用v-if v-bind 为元素绑定属性 指令可简写为: 动态增删class建议使用对象的方式， 例如{active:isActive} v-for 根据数据生成列表结构 数组经常和v-for结合使用 语法是(item,index) in data item和index可以结合其他指令一起使用 数组长度的更新会同步到页面上，是响应式的 v-model 便捷设置和获取表单元素的值 绑定的数据会和表单元素值相关联 绑定数据和表单元素值双向绑定 三、网络应用axios 使用get或post方法发送对应请求 先导入再使用 then方法回调函数会在请求成功或失败时触发 通过回调函数的形参可以获得response内容或错误信息 axios+vue axios中this已经改变，需要提前保存this方便赋值 补充 应用的逻辑代码建议和页面分离，用单独的js文件写 注意服务器返回数据的层级结构 自定义参数可以让代码的复用性提高 methods中定义方法内部可用this关键字调用方法 其他Vue页面加载时，触发某个函数的方法mounted:function()&#123; this.createcode();//需要触发的函数 &#125; //下面是createcode函数 createcode()&#123; var self = this; axios.post(&quot;/verifycode&quot;,&#123;name:this.name,id:this.id&#125;).then(function(res)&#123; //console.log(res); var url= JSON.parse(res.data.code64); //console.log(url) self.urlIMg = url.data.base64Code; &#125;); &#125;,","categories":[{"name":"web笔记","slug":"web笔记","permalink":"https://www.kassama.top/categories/web%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.kassama.top/tags/web/"},{"name":"HTML","slug":"HTML","permalink":"https://www.kassama.top/tags/HTML/"},{"name":"Vue","slug":"Vue","permalink":"https://www.kassama.top/tags/Vue/"}]},{"title":"关于nodejs解决服务器跨域的方法","slug":"关于nodejs跨域问题","date":"2021-01-08T14:42:24.000Z","updated":"2022-09-18T06:02:56.856Z","comments":true,"path":"/webNotes-nodejsKy1.html","link":"","permalink":"https://www.kassama.top/webNotes-nodejsKy1.html","excerpt":"记录一下跨域问题","text":"记录一下跨域问题 首先，什么是跨域？浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域；那么，如何解决跨域呢？ 1、采用jsonp方法解决跨域，2、在服务器端利用nodejs设置头文件header来解决跨域，实例代码如下： const http = require(“http”); http.createServer((req,res)=&gt;&#123; //设置返回格式 JSON, 解决跨域问题 // res.setHeader(&#x27;Content-type&#x27;, &#x27;application/json&#x27;); res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild&quot;); res.setHeader(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;); res.setHeader(&quot;X-Powered-By&quot;,&quot;3.2.1&quot;); res.setHeader(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;); //自己的逻辑代码 &#125;) 请注意上文中强调的setHeader，现在网上有不少博客都直接写成了header方法(原生node没有这个方法)，这是错误的(亲测)，目前Nodejs中res没有header()这个方法，虽然是一个很小的点，但可能在误导很多初学者。同时，请注意头文件的第二行，这样设置会更全面些；","categories":[{"name":"web笔记","slug":"web笔记","permalink":"https://www.kassama.top/categories/web%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.kassama.top/tags/web/"},{"name":"HTML","slug":"HTML","permalink":"https://www.kassama.top/tags/HTML/"}]},{"title":"web学习笔记 - 那些常用又记不住的css","slug":"常用的CSS","date":"2020-10-24T03:48:30.000Z","updated":"2022-09-17T14:54:33.580Z","comments":true,"path":"/webNotes-css1.html","link":"","permalink":"https://www.kassama.top/webNotes-css1.html","excerpt":"记录一些常用Css效果","text":"记录一些常用Css效果 一、设置input 的placeholder的字体样式input::-webkit-input-placeholder &#123; /* Chrome/Opera/Safari */ color: red; &#125; input::-moz-placeholder &#123; /* Firefox 19+ */ color: red; &#125; input:-ms-input-placeholder &#123; /* IE 10+ */ color: red; &#125; input:-moz-placeholder &#123; /* Firefox 18- */ color: red; &#125; 设置input聚焦时的样式input:focus &#123; background-color: red; &#125; 取消input的边框input &#123; border: none; outline: none; &#125; 二、隐藏滚动条或更改滚动条样式/*css主要部分的样式*//*定义滚动条宽高及背景，宽高分别对应横竖滚动条的尺寸*/ ::-webkit-scrollbar &#123; width: 10px; /*对垂直流动条有效*/ height: 10px; /*对水平流动条有效*/ &#125; /*定义滚动条的轨道颜色、内阴影及圆角*/ ::-webkit-scrollbar-track&#123; -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3); background-color: rosybrown; border-radius: 3px; &#125; /*定义滑块颜色、内阴影及圆角*/ ::-webkit-scrollbar-thumb&#123; border-radius: 7px; -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3); background-color: #E8E8E8; &#125; /*定义两端按钮的样式*/ ::-webkit-scrollbar-button &#123; background-color:cyan; &#125; /*定义右下角汇合处的样式*/ ::-webkit-scrollbar-corner &#123; background:khaki; &#125; 三、文字超出隐藏并显示省略号单行（一定要有宽度）p &#123; width:200rpx; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; &#125; 多行p &#123; word-break: break-all; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; &#125; 四、控制div内的元素自动换行div &#123; word-wrap: break-word; word-break：break-all; &#125; 五、 纯css画三角形#demo &#123; width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent transparent red transparent; &#125; 六、 绝对定位元素居中（水平和垂直方向）#demo &#123; width: 200px; height: 200px; position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); background-color: green; &#125; 七、表格边框合并table,tr,td&#123; border: 1px solid #333; &#125; table&#123; border-collapse: collapse; &#125; 参考文档:知乎专栏:那些你常用又记不住的css:","categories":[{"name":"web笔记","slug":"web笔记","permalink":"https://www.kassama.top/categories/web%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.kassama.top/tags/web/"},{"name":"HTML","slug":"HTML","permalink":"https://www.kassama.top/tags/HTML/"}]},{"title":"web学习笔记13 - HTML5和ES6 新特性","slug":"web学习笔记14","date":"2020-05-20T14:32:35.000Z","updated":"2022-09-19T12:55:37.740Z","comments":true,"path":"/webNotesES6.html","link":"","permalink":"https://www.kassama.top/webNotesES6.html","excerpt":"HTML5和ES6新特性封面画师：唏嘘的星辰 p站ID：13312138","text":"HTML5和ES6新特性封面画师：唏嘘的星辰 p站ID：13312138 语义化语义化: 看到它就知道它是干啥的语义化标签: 使用单词作为标签,使标签更容易被识别 常见的语义化标签结构化标签: header, main, footer, nav, aside, hr文本标签: p, h1-h6, strong, i, del 语义化概念什么是HTML语义化？HTML语义化的好处是什么？html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 什么是SEO? 如何做SEO优化?SEO，是英文SearchEngineOptimization的缩写，中文的意思: 搜索引擎优化。SEO的目的就是让网站或者网页在搜索结果中，处于靠前的位置。 实现SEO优化的方式有: 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可；description把页面内容高度概括，不可过分堆砌关键词；keywords列举出重要关键词。 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标。 音视频标签音视频标签的四个属性: src 属性设置音视频资源路径 controls 属性设置播放控制器 autoplay 属性设置自动播放, 需要开启浏览器授权 loop 属性设置循环播放 &lt;audio src=&quot;https://music.163.com/song/media/outer/url?id=28263184.mp3&quot; controls loop&gt;此浏览器不支持播放&lt;/audio&gt; &lt;video src=&quot;./demo.mp4&quot; controls loop&gt;&lt;/video&gt; audio演示：此浏览器不支持播放此浏览器不支持播放 弹性布局流式布局: 网页默认的布局方式, 元素按照行标签从左向右,块标签从上向下依次排列, 尽量不使标签重叠弹性布局: html5新增的网页布局方式, 需要手动设置, 有如下特点: 1，弹性布局总是给父元素设置， 对第一级子元素起效 2，弹性布局元素默认从左向右排列，不换行，高度为100%（包含margin） 3，弹性布局元素没有行标签块标签之分，可以正常设置宽距和宽高 4，弹性布局元素不能使用浮动， 可以使用定位 弹性布局中的属性设置：弹性容器 的属性设置：display: flex; 设置弹性容器flex-wrap: wrap; 设置换行justify-content: space-evenly; 设置说水平对齐方式align-items: center; 设置单行对齐方式align-content: flex-start; 设置多行对齐方式弹性元素 的属性设置：align-self: flex-end; 弹性元素单独对齐order: 1; 弹性元素的排列顺序flex-grow: 2 元素扩展比例flex-shrink: 0; 元素压缩比例 布局 适配 兼容响应式布局 概念: 在浏览器窗口尺寸变化时, 使一个网页在不同宽度的窗口上显示不同的排版样式和内容 使用场景: 一般用于PC端网页 实现原理: 使用媒体查询 浏览器适配 概念: 在浏览器窗口尺寸变化时, 使一个网页在不同宽度的窗口上显示相同的排版样式和内容 使用场景: 一般用于移动端网页 实现原理: 视口单位 vw &#x2F; vh 浏览器兼容 概念: 在不同内核的浏览器上, 使一个网页在不同浏览器的上显示相同的排版样式和内容 使用场景: 在不同内核和不同版本浏览器上的兼容(兼容低版本浏览器) 实现原理: 代码优化 媒体查询媒体查询的结构: @media 媒体类型 and (媒体特性) &#123; 条件满足时,渲染的css样式 &#125; 媒体类型: 此样式会在什么设备上生效 all &#x2F; screen媒体特性: 此样式渲染的条件, min-width &#x2F; max-height 移动端适配适配: 在不同的设备上显示相同的样式 viewport: 视口, 可视窗口, 一般指移动端屏幕窗口 移动端视口中有两个长度单位 vw 和 vh vw: viewportWidth 视口宽度 100vw &#x3D;&#x3D; 视口宽度 vh: viewportHeight 视口高度 100vh &#x3D;&#x3D; 视口高度 100% 和 100vw 的区别 100% 指的是父标签宽度 100vw 指得是宽口宽度 注意: 移动端竖向滚动条不占宽度, 所以移动端 100vw &#x3D;&#x3D; 100%结论: 建议PC端用100%, 移动端用100vw ES6es6: ECMA script 6 ECMAScript 是javascript的一种语法标准 es6 第六版js语法 ECMA : European Computer Manufacturers 2Xf2E6aEU7n685eHEbXGYHrmWn2y7a62UWBrtZzodVdD 截止目前，各大浏览器都已经实现了es6标准的90%以上。nodejs几乎完全支持es6。 参考教程: http://jsrun.net/t/cZKKp requestAnimationFramerequestAnimationFrame 和 setTimeout 类似, 都是一个短暂不重复的计时器 setTimeout可自定义计时时间 requestAnimationFrame 的计时时间是默认的, 一帧的时间,约等于16.67ms requestAnimationFrame 优点: 在保证动画流畅运行的前提下, 最大限度的节约性能消耗 由于收到设备性能的影响, 网页的刷新率(帧率)不一定准确维持在60帧&#x2F;s, 可能偏高或偏低, 所以16.67ms的帧时间是一个大概的值,不是定值 // 使用setInterval实现小球d1运动 var y1 = 0 setInterval(() =&gt; &#123; y1 += 1 if(y1 &gt;= 600) y1 = 0 d1.style.top = y1 + &quot;px&quot; &#125;, 16.67); // 使用setTimeout实现小球d2运动 var y2 = 0 function move()&#123; y2 += 1 if(y2 &gt;= 600) y2 = 0 d2.style.top = y2 + &quot;px&quot; setTimeout(move, 16.67); // 递归 &#125; setTimeout(move, 16.67); // 使用requestAnimationFrame实现小球d3运动 var y3 = 0 function move1()&#123; y3 += 1 if(y3 &gt;= 600) y3 = 0 d3.style.top = y3 + &quot;px&quot; requestAnimationFrame(move1); // 递归 &#125; requestAnimationFrame(move1); 地理定位navigator.geolocation 是H5新增的API,用于浏览器获取位置信息 window.navigator.geolocation.getCurrentPosition(res=&gt;&#123; console.log(res.coords) // accuracy: 55 定位精度 // ​ // altitude: 0 海拔高度 // ​ // altitudeAccuracy: 0 海拔精确度 // ​ // heading: null 移动方向 // ​ // latitude: 34.72326699999999 纬度 // ​ // longitude: 113.75165477777777 经度 // ​ // speed: null 移动速度 &#125;) // 开启位置监视后, 直接获取位置失效 // 开始监控位置 var watch = navigator.geolocation.watchPosition(res=&gt;&#123; console.log(&quot;位置更新&quot;, res) &#125;) // 取消监听 setTimeout(() =&gt; &#123; navigator.geolocation.clearWatch(watch) &#125;, 10000); 百度地图&lt;!-- 引用百度地图API3.0文件 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://api.map.baidu.com/api?v=3.0&amp;ak=你自己の密钥&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://api.map.baidu.com/api?v=1.0&amp;&amp;type=webgl&amp;ak=你自己の密钥&quot;&gt; &lt;/script&gt; &lt;!-- 创建地图容器元素 --&gt; &lt;div id=&quot;container&quot;&gt;&lt;/div&gt; &lt;button onclick=&quot;getEarth()&quot;&gt;开启地球模式&lt;/button&gt; &lt;script&gt; // 创建地图实例 var map = new BMap.Map(&quot;container&quot;); // 设置中心点坐标 var point = new BMap.Point(116.404, 39.915); // 地图初始化，同时设置地图展示级别 map.centerAndZoom(point, 15); // 获取当前位置 navigator.geolocation.getCurrentPosition(res=&gt;&#123; // panTo()方法将让地图平滑移动至新中心点 map.panTo(new BMap.Point(res.coords.longitude, res.coords.latitude)); // 逆地址解析 // 创建地理编码实例, 并配置参数获取乡镇级数据 var myGeo = new BMap.Geocoder(&#123;extensions_town: true&#125;); // 根据坐标得到地址描述 myGeo.getLocation(new BMap.Point(res.coords.longitude, res.coords.latitude), function(result)&#123; if (result)&#123; alert(result.address); &#125; &#125;); &#125;) //开启鼠标滚轮缩放 map.enableScrollWheelZoom(true); // 添加平移缩放控件 map.addControl(new BMap.NavigationControl()); // 比例尺控件 map.addControl(new BMap.ScaleControl()); // 缩略图控件 map.addControl(new BMap.OverviewMapControl()); // 地图类型 map.addControl(new BMap.MapTypeControl()); // 添加路况图层 var traffic = new BMap.TrafficLayer(); map.addTileLayer(traffic); // 圆形区域搜索 var local = new BMap.LocalSearch(map,&#123; renderOptions:&#123; map: map, autoViewport: true &#125; &#125;); // 在天安门附近搜索银行 local.searchNearby(&quot;漫展&quot;,&quot;上海&quot;); &lt;/script&gt; &lt;script&gt; // 点击按钮切换地球模式 function getEarth()&#123; console.log(123) var map = new BMapGL.Map(&quot;container&quot;); var point = new BMapGL.Point(116.404, 39.915); map.centerAndZoom(point, 1); map.enableScrollWheelZoom(true); map.setMapType(BMAP_EARTH_MAP); &#125; &lt;/script&gt; canvas画布canvas绘图Api在script标签中添加如下注释,即可自动提示canvas API/** @type &#123;HTMLCanvasElement&#125; 添加canvas API语法提示*/(一) 方法: getContext(&quot;2d&quot;) 创建绘图对象 beginPath(); 开始绘制路径 closePath(); 结束绘制路径,闭合线框 moveTo(x,y); 移动到绘制起点 lineTo(x,y); 画线段到指定点 arc(x,y,r,start,end); 绘制圆形(弧度单位) quadraticCurveTo(x,y,endX,endY) 二次贝塞尔曲线 bezierCurveTo(x1,y1,x2,y2,endX,endY) 三次贝塞尔曲线 stroke(); 线条类型 fill(); 填充类型 fillRect(x,y,w,h) 填充矩形 strokeRect(x,y,w,h) 线框矩形 clearRect(x,y,w,h) 清除矩形 strokeText(string,x,y) 绘制线条文字(空心) fillText(string,x,y) 绘制填充文字(实心) drawImage(img,x,y,width,height) 绘制图片(需在img的load函数中) save() 保存当前状态设定 restore() 恢复到保存之前的状态设定 rotate() 旋转画布角度(弧度制) (二) 属性: fillStyle 填充颜色(支持rgb(),#fff,red) strokeStyle 线条颜色 lineWidth 线条宽度(整数值,默认单位px) lineJoin 折线拐角类型 (round表示圆角) font 支持多个值, 例如”10px 宋体” textBaseline 文字基点(默认bottom左下为基准点, top为左上) globalCompositeOperation 绘制合成(具体值参考附件) canvas语法&lt;style&gt; canvas&#123; border: 1px solid; /* css设置尺寸只能缩放画布,不能改变画布实际尺寸 */ /* height: 600px; */ &#125; &lt;/style&gt; &lt;body&gt; &lt;!-- 属性height/width设置的才是画布的实际尺寸 --&gt; &lt;canvas id=&quot;myCanvas&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt; &lt;script&gt; // 获取canvas标签元素 /** @type &#123;HTMLCanvasElement&#125; 添加canvas API语法提示*/ var canvas = document.getElementById(&quot;myCanvas&quot;) // 通过canvas标签获取一个绘图对象 var ctx = canvas.getContext(&quot;2d&quot;) // 1, 绘制线段 ctx.moveTo(20, 20); // 设置绘制起点 ctx.lineTo(120, 20); // 绘制线段到终点 ctx.lineTo(120, 120); // 绘制线段到另一个终点 ctx.lineTo(20, 120); ctx.lineTo(20, 20); ctx.moveTo(20,70); // 设置另一个绘制起点 ctx.lineTo(120,70); ctx.moveTo(70, 20); // 设置另一个绘制起点 ctx.lineTo(70,120); ctx.stroke(); // 执行绘制线段 // 2, 绘制线框矩形 ctx.strokeRect(150, 20, 100, 60); // 绘制填充矩形 ctx.fillRect(150, 100, 100, 60); // 清理矩形区域 ctx.clearRect(180, 130, 20, 20); // 3, 绘制弧形和扇形 // ctx.moveTo(120, 200) // 先移动移动到圆弧起点 ctx.beginPath() // 开始另一个绘制路径 ctx.arc(70, 200, 50, 0, Math.PI); // ctx.stroke() // 圆弧 ctx.fill() // 扇形区域 ctx.closePath() // 结束另一个绘制路径 // 4, 绘制曲线 // 二次贝塞尔曲线 ctx.moveTo(20, 300); // 曲线起点 ctx.quadraticCurveTo(100, 200, 240, 300); ctx.stroke() // 三次内塞尔曲线 ctx.beginPath() ctx.strokeStyle = &quot;yellow&quot;; ctx.lineWidth = 2; ctx.moveTo(20, 400);// 曲线起点 ctx.bezierCurveTo(100, 200, 200, 500, 240, 330); ctx.stroke() ctx.closePath() // 5, 绘制文字 ctx.font = &quot;50px 楷体&quot;; ctx.strokeStyle = &quot;red&quot;; ctx.lineWidth = 1 ctx.fillStyle = &quot;green&quot; ctx.strokeText(&quot;饕餮&quot;, 20, 500); ctx.fillText(&quot;王粲博&quot;, 150, 500); // 6, 绘制图片 var img = document.createElement(&quot;img&quot;) img.src = &quot;./item338.gif&quot; // 不能直接绘制图片,需要在img的load事件中绘制 img.onload = function()&#123; ctx.drawImage(img, 20, 520, 260, 80) &#125; &lt;/script&gt; &lt;/body&gt; 实例：刮刮乐&lt;style&gt; canvas&#123; position: relative; background-image: url(item338.gif); background-size: 100% 100%; &#125; &lt;/style&gt; &lt;body&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;script&gt; /** @type &#123;HTMLCanvasElement&#125; 添加canvas API语法提示*/ var canvas = document.getElementById(&quot;canvas&quot;) var ctx = canvas.getContext(&quot;2d&quot;) // 先绘制灰色图层 ctx.fillStyle = &#x27;gray&#x27;; ctx.fillRect(0,0,300,150); // 再绘制提示文字 ctx.font = &quot;30px 黑体&quot; ctx.fillStyle = &quot;green&quot; ctx.fillText(&#x27;刮开有惊喜&#x27;, 60, 80); // 图层叠加 (目标图像是已经绘制的图层, 源图像是即将绘制的图像) ctx.globalCompositeOperation = &quot;destination-out&quot; // 刮图层的函数 function gua(e)&#123; ctx.beginPath() // e.pageX 相对于网页, e.layerX 相对于非静态定位元素 ctx.arc(e.layerX, e.layerY, 20, 0, Math.PI*2) ctx.fill() &#125; // 鼠标按下,开始绘制圆形 canvas.onmousedown = function()&#123; canvas.addEventListener(&quot;mousemove&quot;, gua) &#125; // 鼠标抬起, 停止绘制 canvas.onmouseup = function()&#123; canvas.removeEventListener(&quot;mousemove&quot;, gua) &#125; &lt;/script&gt; &lt;/body&gt; WebWoker概念进程: 一个应用的代码执行流程, 一个应用有且仅有一个进程线程: 也叫分线程, 可以独立于主线程执行, 通过代码创建, 可以没有也可以有多个主线程: 同 进程分线程: 同 线程 总结:分线程使用的API:new Worker() 创建分线程postMessage() 线程之间发送数据onmessage 事件,接收线程发送的数据 注意事项: 1, 分线程不能调用界面相关API,只有主线程可以操作界面 2, 线程之能同源访问, 跨域无法引入分线程脚本, 网页不能使用file协议本地打开 3, 分线程和主线程作用域相互隔离,不能直接调用数据, 需要使用postMessage和onmessage发送和接收 4, 分线程不能执行界面相关的alert()等API,但可以执行与界面无关的ajax请求 5, 分线程无法读取本地文件, 分线程中的数据都要来源于网络 参考教程: http://www.ruanyifeng.com/blog/2018/07/web-worker.html 块级作用域var 关键字定义变量有两个作用域 全局作用域 和 局部作用域let 关键字定义变量有三个作用域 全局作用域, 局部作用域 和 块级作用域全局变量: 在全局范围内定义的变量局部变量: 在函数内部定义的变量块级变量: 在语法块中定义的变量 比如循环,判断语法块 举例: 使用在语法块中定义的变量,只能在语法块中使用 if(true)&#123; var d = 4; let e = 5; &#125; // console.log(d) // 4 // console.log(e) // undefined 举例: 在循环中, 实现延时打印 for(let i = 0; i &lt; 5; i++)&#123; // 在循环中使用var定义变量, 这个变量是全局变量, 每次循环的count共享同一个作用域, 所以下次循环的count把替换上次循环的count, 循环之后,全局只有一个count,值为4 var count = i; // console.log(count) // 0,1,2,3,4 setTimeout(() =&gt; &#123; console.log(count) // 4,4,4,4,4 &#125;, 100); // 在循环中使用let定义变量, 这个变量是块级变量, 每次循环都会在一个新的块级作用域中定义一个独立块级变量number, 循环结束后, 就有5个块级变量number,他们的值各不相同, 互补影响 let number = i; setTimeout(() =&gt; &#123; console.log(number) // 0,1,2,3,4 &#125;, 200); &#125; // console.log(i) // undefined 循环变量i建议使用let定义, 再循环之外无法调用, 也就避免了全局作用域污染 如果要在循环中添加计时器或事件绑定, 需要保留每次循环的变量值, 有以下两种解决方案, 使用let定义块级变量for(let i = 0; i &lt; 5; i ++)&#123; setTimeout(()=&gt;&#123; console.log(i) &#125;, 300); &#125; 使用闭包, 保持count局部变量function outter(count)&#123; return function inner()&#123; console.log(count) &#125; &#125; for(var i = 0; i &lt; 5; i ++)&#123; setTimeout(outter(i), 300); &#125; let和var的两点主要区别: var 在同一作用域可以重复定义同一个变量, let不行 var 没有块级作用域, 在循环中定义的变量都是全局的, 会相互覆盖, let在循环中定义的变量都是独立的,互不影响 const常量ES6新增了两个关键字 let 定义变量 const 定义常量const 定义值类型数据, 绝对不能改const 定义引用类型数据, 数据内容(对象&#x2F;数组中的数据)可以改, 引用类型本身(内存地址)不能改 字符串模板如果要把字符串和变量拼接到一起, 有两种写法 var year = 2020, month = 4, day = 20; // 1, ES5字符串拼接 console.log(year + &quot;年&quot; + month + &#x27;月&#x27; + day + &quot;日&quot;) // 2, es6模板字符串 console.log(`$&#123;year&#125;年$&#123;month&#125;月$&#123;day&#125;日`) // 由于模板字符串支持换行, 所以可以用来渲染标签字符串 var htmlStr = ` &lt;ul&gt; &lt;li&gt;$&#123;year&#125;年&lt;/li&gt; &lt;li&gt;$&#123;month&#125;月&lt;/li&gt; &lt;li&gt;$&#123;day&#125;日&lt;/li&gt; &lt;/ul&gt; ` console.log(htmlStr) 箭头函数箭头函数用法: 在事件函数或计时器或异步回调函数中可以保留this上下文指向 箭头函数在参数和返回值处,满足条件时,都可以简化 在对象中有一个简化的函数写法 // 普通的function函数不能转化为箭头函数 function add()&#123; &#125; // 只有匿名函数可以转化为箭头函数 var add = function()&#123; &#125; var add = ()=&gt;&#123;&#125; // 在node环境下, this默认指向空对象 console.log(1, this) // &#123;&#125; // 可以修改这个对象 this.name = &quot;zhangsan&quot; console.log(2, this) // &#123;name: &quot;zhangsan&quot;&#125; // setTimeout会把this指向修改为Timeout对象 setTimeout(function()&#123; console.log(3, this) // Timeout &#125;, 1000); // 箭头函数会保留this的上下文指向, 使this指向和setTimeout外部相同 setTimeout(() =&gt; &#123; console.log(4, this) // &#123;name: &quot;zhangsan&quot;&#125; &#125;, 1000); // 箭头函数的简化 var add = (count)=&gt;&#123; // return count ++ return ++ count &#125; console.log(add(5)) // 如果箭头函数只有一个参数, 可以省略小括号 var add = count =&gt; &#123; return ++ count; &#125; // 如果箭头函数的函数体中只有一句return返回, return和&#123;&#125;可同时省略 var add = count =&gt; ++count; console.log(add(100)) // 箭头函数在对象中的写法, 对象中的函数有以下三种写法 var student = &#123; name: &quot;张三&quot;, age: 20, // ES5函数的写法, 其中的this是当前对象 eat: function()&#123; console.log(this.name+&quot;吃饭&quot;) &#125;, // ES6箭头函数写法, 其中的this是对象上下文(全局作用域)指向 drink: ()=&gt;&#123; console.log(this.name+&quot;喝水&quot;) &#125;, // 简化写法, 其中this的指向还是当前对象 sleep()&#123; console.log(this.name+&quot;睡觉&quot;) &#125; &#125; student.eat() student.drink() student.sleep() 数组对象数组解构: var [count1,count2,...count3] = array数组赋值1: array.push(…array2)数组赋值2: array &#x3D; […array, …array2, 5,6,7]对象解构: var { age } &#x3D; student对象赋值: {…student, height:120} // 数组的解构 var array = [1,2,3,4] // 一般,使用数组中的数据要使用索引取值 console.log(array[1]) // 数组解构允许我们直接使用变量读取数组中的数据 let [count1, count2, count3, count4] = array console.log(count3) // 注意: 由于数组有顺序,在解构时,一般前边变量个数和数组中数据个数要一一对应 // 可以使用 ... 语法解构数组中的一部分数据(靠后的好几条数据) let [num1, ...num2] = array console.log(num2) // 数组的赋值 var array2 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] // 需求: 把array2拼接到array中 // 方法1: 循环array2把array2的每一条数据加入array中 // array2.forEach(item=&gt;&#123; // array.push(item) // &#125;) // console.log(array) // 方法2: 使用concat数组拼接API // array = array.concat(array2) // console.log(array) // 方法3: 使用 ... 数组赋值 array.push(...array2) console.log(array) // 数组也可以如下拼接 array = [...array, ...array2, 5,6,7] console.log(array) // 对象的解构 var student = &#123; name: &quot;张三&quot;, age: 12, sex: &quot;男&quot;, phone: &quot;110&quot; &#125; console.log(student) // 如果要获取一个对象中的某个字段, 直接用对象打点调用即可 console.log(student.phone) // 也可以使用对象解构写法获取某个字段值 var &#123; age, sex &#125; = student; console.log(age, sex) // 注意: 由于对象中的数据没有顺序, 所有对象解构无需把所有字段都写上,可以按需定义变量读取对象中的某一个或几个字段即可, 但必须保证变量名和字段名相同 // 把student这个对象中的数据拼接到people对象中 var people = &#123; height: 120, weight: 180, ...student &#125; console.log(people) // 字符串解构, 和数组解构类似 var string = &quot;ABC&quot; var [a,b,c] = string; console.log(a,b,c) 数组对象拼接数组拼接var array1 = [1,2,3]var array2 = [4,5,6]console.log([...array1, ...array2, 7,8,9]) [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ] 对象拼接var obj1 = &#123; age: 20 &#125;var obj2 = &#123; sex: true &#125;console.log(&#123;...obj1, ...obj2&#125;) { age: 20, sex: true } 参数的默认值function add1(a,b)&#123; console.log(a+b) &#125; add1() // NaN add1(3) // NaN add1(3,4) // 7 add1(3,4,5) // 7 // js函数定义时有两个参数, 调用时就必须传入至少两个参数, // 如果传入的实参少于形参的个数,为防止错误, 可以给形参设置默认值 // ES5中使用 || 设置默认值 function add2(a,b)&#123; a = a || 0; //设置默认值 b = b || 0; //设置默认值 console.log( a + b ) &#125; add2() // 0 add2(3) // 3 add2(3,4) // 7 add2(3,4,5) // 7 // ES6中使用 初始化形参 设置默认值 function add3(a=0, b=0)&#123; console.log( a + b ) &#125; add3() // 0 add3(3) // 3 add3(3,4) // 7 add3(3,4,5) // 7 // 关于函数的参数, 如果参数个数不确定, 如果获取所有参数 // ES5中通过arguments字段获取参数数组 function add4()&#123; // arguments是一个类数组, 里边放了所有参数 console.log(arguments, Array.from(arguments)) &#125; add4() // &#123;&#125; [] add4(3) // &#123;&quot;0&quot;: 3&#125; [3] add4(3,4) // &#123;&quot;0&quot;:3, &quot;1&quot;: 4&#125; [3,4] add4(3,4,5) // &#123;&#x27;0&#x27;: 3, &#x27;1&#x27;: 4, &#x27;2&#x27;: 5 &#125; [3,4,5] // ES6中通过形参...arr获取参数数组 function add5(...array)&#123; // 形参array是所有参数所在的数组 console.log(array) &#125; add5() // [] add5(3) // [3] add5(3,4) // [3,4] add5(3,4,5) // [3,4,5] PromisePromise的由来js代码执行过程中,分为同步执行和异步执行的两种代码执行逻辑同步执行: 代码总是从上向下依次执行,只有上一句执行完,才会执行下一句, 默认js是通过异步执行: 特殊形况下,异步代码可以和其他代码同时执行,相互不影响,不严格按照顺序执行, 常见的异步执行逻辑有 计时器, js事件, ajax, promise调用异步代码的标志性特点是: 回调函数结论: 一段逻辑代码中,总是先执行同步代码, 再执行异步代码 上代码： // 这是正常的函数返回值调用 function getRandom()&#123; return Math.random() &#125; var random = getRandom() console.log(1, random) // 当函数中有异步操作时,能否return返回异步结果 function getRandom2()&#123; setTimeout(() =&gt; &#123; console.log(3) return Math.random()// 异步函数中的return是无效的 &#125;, 100); &#125; var random2 = getRandom2() console.log(2, random2) // 2 undefined Promise的语法// Promise 在es6中属于一个 类 要通过new创建promise对象使用, 如下 // 新建一个promise对象, 参数是一个同步函数, 同步函数的参数是成功和失败的回调函数 var p = new Promise(function(resolve, reject)&#123; // 使用new创建promise对象这个操作是同步操作还是异步操作? 同步的 console.log(1) // 在promise对象中执行异步任务 setTimeout(() =&gt; &#123; console.log(3) var random = Math.random() if(random &gt; 0.5)&#123; resolve(&quot;成功&quot;) &#125;else&#123; reject(&quot;失败&quot;) &#125; &#125;, 100); &#125;) console.log(2) // 使用promise对象调用函数then拿成功的数据, 调用catch拿失败的数据 p.then(data=&gt;&#123; console.log(4, data) &#125;) p.catch(err=&gt;&#123; console.log(4, err) &#125;) // promise支持链式调用 p.then().catch().then().then(data=&gt;&#123; console.log(5, data) &#125;).then() // promise无论何时,何地,多次调用then,总能拿到成功时的数据 // 注意: Promise对象的创建过程是同步的, then函数的调用是异步的, 简单说peomise是异步的 Promise示例// 需求: 在四个异步操作中打印四句话,而且要保证打印顺序 // setTimeout(() =&gt; &#123; // console.log(&quot;窗前明月光&quot;) // &#125;, Math.random()*1000); // setTimeout(() =&gt; &#123; // console.log(&quot;疑似地上霜&quot;) // &#125;, Math.random()*1000); // setTimeout(() =&gt; &#123; // console.log(&quot;举头望明月&quot;) // &#125;, Math.random()*1000); // setTimeout(() =&gt; &#123; // console.log(&quot;低头鞋两双&quot;) // &#125;, Math.random()*1000); // 方法一: 四个计时器嵌套, 上一个执行后再执行下一个 // setTimeout(() =&gt; &#123; // console.log(&quot;窗前明月光&quot;); // setTimeout(() =&gt; &#123; // console.log(&quot;疑似地上霜&quot;); // setTimeout(() =&gt; &#123; // console.log(&quot;举头望明月&quot;); // setTimeout(() =&gt; &#123; // console.log(&quot;低头鞋两双&quot;) // &#125;, Math.random()*1000); // &#125;, Math.random()*1000); // &#125;, Math.random()*1000); // &#125;, Math.random()*1000); // 此方法有两个缺点: // 1, 代码多层嵌套造成结构复杂,可读性差 // 2, 四句打印的计时时间累加起来了, 降低效率 // 首先, 我们使用promise解决异步任务多层嵌套问题 // new Promise(function(resolve)&#123; // setTimeout(() =&gt; &#123; // console.log(&quot;窗前明月光&quot;); resolve() // 调用resolve以执行then // &#125;, Math.random()*1000); // &#125;).then(function()&#123; // return new Promise(function(resolve)&#123; // setTimeout(() =&gt; &#123; // console.log(&quot;疑似地上霜&quot;); resolve() // 调用resolve以执行then // &#125;, Math.random()*1000); // &#125;) // &#125;).then(function()&#123; // return new Promise(function(resolve)&#123; // setTimeout(() =&gt; &#123; // console.log(&quot;举头望明月&quot;); resolve() // 调用resolve以执行then // &#125;, Math.random()*1000); // &#125;) // &#125;).then(function()&#123; // return new Promise(function(resolve)&#123; // setTimeout(() =&gt; &#123; // console.log(&quot;低头鞋两双&quot;); resolve() // 调用resolve以执行then // &#125;, Math.random()*1000); // &#125;) // &#125;) // 然后, 我们使用promise解决 多异步任务并发 的顺序问题 var p1 = new Promise(function(resolve)&#123; setTimeout(() =&gt; &#123; resolve(&quot;窗前明月光&quot;) &#125;, Math.random()*1000); &#125;) var p2 = new Promise(function(resolve)&#123; setTimeout(() =&gt; &#123; resolve(&quot;疑似地上霜&quot;) &#125;, Math.random()*1000); &#125;) var p3 = new Promise(function(resolve)&#123; setTimeout(() =&gt; &#123; resolve(&quot;举头望明月&quot;) &#125;, Math.random()*1000); &#125;) var p4 = new Promise(function(resolve)&#123; setTimeout(() =&gt; &#123; resolve(&quot;低头鞋两双&quot;) &#125;, Math.random()*1000); &#125;) // Promise有一个类函数all, 可以把多个promise对象合并成一个 var p = Promise.all([p1,p2,p3,p4]) // 当合并前的所有promise对象都调用resolve后, 才会调用合并后的then p.then(function(array)&#123; // all合并后的then回调函数参数是一个数组, 数组中按照合并顺序依次获取每一个promise对象的成功数据 console.log(array) &#125;) // 类函数: 就是使用类名调用的函数 如 all() // 实例函数: 就是使用对象调用的函数 如 then() // 总结: 说一下你对promise的理解? // promise 是es6新增的一个类,主要用于解决项目开发中常见异步回掉地域问题,原理上是对回调函数的封装, 开发中经常用于多异步任务嵌套时和多异步任务并发时 async和await// 在es6新增了一个关键字 叫 async 用于放在函数function前,修饰函数 function a ()&#123; console.log(&#x27;a&#x27;) &#125; a() // 在函数前添加async标记可以使此函数变为异步函数 async function b()&#123; console.log(&#x27;b&#x27;) &#125; b() // 箭头函数也可以定义为异步函数 var c = async ()=&gt;&#123; console.log(&#x27;c&#x27;) return &quot;彬哥&quot; // 即使有返回值, 调用得到的也是promise &#125; c() // async异步函数的返回值总是一个promise对象 console.log(a()) console.log(b()) console.log(c()) async function d()&#123; var p = new Promise(resolve=&gt;&#123; setTimeout(() =&gt; &#123; resolve(&quot;成功&quot;) &#125;, 1000); &#125;) // 调用then函数,在异步回调函数中获取数据 p.then(data=&gt;&#123; console.log(1,data) &#125;) // await关键字一般放在promise对象前边, 等待promise对象成功的结果,一旦成功, 无需调用then, 而是通过同步返回值的形式拿到promise中的异步结果 var res = await p console.log(2,res) // await 的作用就是让异步回调结构改成同步返回值结构,依然能拿到数据, 好处是简化代码结构, 减少嵌套, 优化语法结构 // await is only valid in async function await只能在async函数中使用 &#125; console.log(d()) ES6模块化 模块化: 把一个整体的js文件或代码块通过功能性分割成多个js文件或代码块, 这样每一个js文件都称之为一个模块, 然后通过固定语法导入&#x2F;导出把多个js文件联系到一起, 这种操作,我们称之为模块化 html文件中使用script导入js算不算模块化?答: 不算, 因为模块化有一个显著特点,是作用域隔离, 各个模块用于各自独立的作用, 互不干涉, 用script导入js相当于把所有js拼到一起了,共享了同一个作用域,这种不能称之为模块化 模块化语法:导出: export default data导入: import data from &quot;path&quot; 从模块myModule中导入数据myModule.js var count = 100 // 使用模块化语法把数据导出 export default count index.js import count from &quot;./myModule.js&quot; // Cannot use import statement outside a module // 不识别import这个语法, 因为es6模块化语法是不能直接在node或浏览器执行的 console.log(count) es6模块化一般用于vue框架或react框架中","categories":[{"name":"web笔记","slug":"web笔记","permalink":"https://www.kassama.top/categories/web%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.kassama.top/tags/web/"},{"name":"HTML","slug":"HTML","permalink":"https://www.kassama.top/tags/HTML/"}]},{"title":"宠物养成使用教程","slug":"宠物养成使用教程","date":"2020-05-09T04:42:12.000Z","updated":"2022-04-08T08:31:38.338Z","comments":true,"path":"/usepet.html","link":"","permalink":"https://www.kassama.top/usepet.html","excerpt":"本篇教程尚未完成，仅供参考","text":"本篇教程尚未完成，仅供参考 首先，应该先下载cpk文件和数据包（在论坛下载过的不需要再次下载） 插件本体：点我下载 数据文件：点我下载 图片文件：点我下载 AIR用户无法发图，AIR即是免费版机器人 下载完成后，打开酷Q根目录，把压缩包内的文件全部拖入文件夹即可，然后重启机器人即可。 图片教程： [&#x2F;successbox] [infobox title&#x3D;”宠物养成指令”] 宠物养成默认指令如下： 补充： 宠物交易： 宠物交易@QQ*物品×数量#交易价格 接受交易、拒绝交易、取消交易 家族列表、家族成员 感谢主群群员@白鲮(24893****)的图片 [&#x2F;infobox] [infobox title&#x3D;”控制台部分解释”] 核心配置 初始宠物：分隔符#，可添加或减少宠物 消息前缀：可空，但最好有前缀 主人QQ：为以后的功能做铺垫，请务必填写 屏蔽前缀指令：不想使用前缀的指令，请添加到这里，可以无视前缀使用 开启群号：分隔符#，可以多群，不填默认全部群开启。 货币对接 货币对接路径：需要填写完整的路径，例如：F:\\酷Q Pro\\data\\app\\cc.kasiwuhui.Text\\玩家数据\\玩家信息.ini 货币配置节：配置节就是ini文件里“[]”中括号里面的文本，如果是群号就可以填写变量[群号]，如果是QQ就可以填写变量[QQ] 货币配置项：配置项就是ini文件里“[]”中括号下面&#x3D;等号前面的数据，如果是群号就可以填写变量[群号]，如果是QQ就可以填写变量[QQ] 交易 交易最低货币：交易时所出的货币最低不能少于这个数值 交易手续费：交易成功后所收取的手续费 抽奖 抽奖需要物品：物品*数量 抽奖奖励设置：即奖池，几率%物品*最低数量~最高数量，分隔符为#，至少配置一个100%的奖励，否则会崩溃 [&#x2F;infobox]","categories":[{"name":"wiki","slug":"wiki","permalink":"https://www.kassama.top/categories/wiki/"}],"tags":[{"name":"wiki","slug":"wiki","permalink":"https://www.kassama.top/tags/wiki/"},{"name":"宠物养成","slug":"宠物养成","permalink":"https://www.kassama.top/tags/%E5%AE%A0%E7%89%A9%E5%85%BB%E6%88%90/"}]},{"title":"web学习笔记13 - Ajax","slug":"web学习笔记13","date":"2020-05-02T11:28:30.000Z","updated":"2022-09-17T14:47:23.710Z","comments":true,"path":"/webNotes-Ajax1.html","link":"","permalink":"https://www.kassama.top/webNotes-Ajax1.html","excerpt":"Ajax学习笔记","text":"Ajax学习笔记 AJAX的学习笔记(Node.js环境)AJAX学习的笔记，主要环境为Node.js 课程地址： https://www.bilibili.com/video/BV1WC4y1b78y HTTPHTTP（hypertext transport protocol）协议『超文本传输协议』，协议详细规定了浏览器和万维网服务器之间互相通信的规则。约定, 规则 请求报文重点是格式与参数 行 POST /s?ie=utf-8 HTTP/1.1 头 Host: kassama.top Cookie: name=kass Content-type: application/x-www-form-urlencoded User-Agent: chrome 83 空行 响应报文行 HTTP/1.1 200 OK 头 Content-Type: text/html;charset=utf-8 Content-length: 2048 Content-encoding: gzip 空行 体 &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;咔斯Sma&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 404 403 401 500 200 第一章： 原生Ajax1.1 Ajax简介 Ajax全称为Asynchronous Javascript And XML，即异步JS和XML 通过Ajax可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据 AJAX不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式 1.2 XML简介 XML：可扩展标记语言 XML：被设计用来传输和存储数据 XML和HTML类似，不同点：HTML中都是预定义标签，XML中没有预定义标签，全是自定义标签，用来表示一些数据 现在已被JSON取代 1.3 AJAX 的特点1.3.1 AJAX的优点 可以无刷新页面与服务端进行通信 允许你根据用户事件来更新部分页面内容 1.3.2 AJAX 的缺点 没有浏览历史，不能回退 存在跨域问题（同源） SEO不友好（爬虫获取不到信息） 1.4 AJAX 的使用1.4.1 核心对象第二章 jQuery中的AJAX2.1 get请求$.get(url, [data], [callback], [type]) url: 请求的URL地址 data: 请求携带的参数 callbac: 载入成功时回调函数 type：设置返回内容格式，xml、html、script、json、text、_default 2.2 post请求$.post(url, [data], [callback], [type]) url: 请求的URL地址 data: 请求携带的参数 callbac: 载入成功时回调函数 type：设置返回内容格式，xml、html、script、json、text、_default 第三章： 跨域3.1 同源策略同源策略（Same-Origin Policy）最早由 Netscape 公司提出，是浏览器的一种安全策略。 同源：协议、域名、端口号 必须完全相同 违背同源策略就是跨域 3.2 如何解决跨域3.2.1 JSONP JSONP是什么 JSONP (JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来，只支持get请求 JSONP 怎么工作的？ 在网页有一些标签天生具有跨域能力，比如：img, link, iframe, script JSONP就是利用script标签的跨域能力来发送请求的 JSONP的使用 动态的创建一个script标签 var script = document.createElement(&quot;script&quot;); 设置script的src，设置回调函数 script.src = &quot;http://locallhost:3000/textAJAX?callback=abc&quot; 3.2.2 CORS推荐阅读： http://www.ruanyifeng.com/blog/2016/04/cors.html https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS CORS是什么？ CORS (Cross-Origin Resource Sharing), 跨域资源共享。CORS 是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 等请求。跨域资源共享标准新增了一组 HTTP 首部字段（响应头），允许服务器声明哪些源站通过浏览器有权限访问哪些资源 CORS怎么工作的？ CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行。 CORS 的使用 主要是服务端的设置： rounter.get(&quot;/testAJAX&quot;,function(req, res)&#123; &#125;)","categories":[{"name":"web笔记","slug":"web笔记","permalink":"https://www.kassama.top/categories/web%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.kassama.top/tags/web/"},{"name":"HTML","slug":"HTML","permalink":"https://www.kassama.top/tags/HTML/"}]},{"title":"web学习笔记12 - 递归和定时器","slug":"web学习笔记12","date":"2020-04-20T14:32:35.000Z","updated":"2022-09-19T12:55:37.737Z","comments":true,"path":"/webNotes12.html","link":"","permalink":"https://www.kassama.top/webNotes12.html","excerpt":"递归和定时器 学习总结最近学的有点乱 - -封面画师：唏嘘的星辰 p站ID：13312138","text":"递归和定时器 学习总结最近学的有点乱 - -封面画师：唏嘘的星辰 p站ID：13312138 递归递归 自己调用自己，需要在合适地方跳出方法 return进行跳出 function f1(n)&#123; console.log(n,&quot;------&quot;) // 3 2 1 0 // f1(3) //递归调用 if(n&gt;0)&#123; f1(n-1) //f1(2) f1(1) f1(0) &#125; console.log(n,&quot;++++++++&quot;) // 0 1 2 3 &#125; f1(3) // 第25位数是多少 斐波那契数列 // 1 1 2 3 5 8 13 21... function f2(n)&#123; if(n&lt;3)&#123; return 1 &#125; return f2(n-1) + f2(n-2) &#125; console.log(f2(40)) /* 5 f2(4)+f2(3)=f2(3)+f2(2)+f2(3) = f2(2)+f2(1)+1+f2(2)+f2(1) =1+1 +1 + 1+ 1 = 5 */ // 9！=1 * 2 *3*...9 // n的阶乘 9！= 9*8！=9 * 8 *7! function f3(n)&#123; if(n==1)&#123; return 1 &#125; // arguments.callee() 不使用函数名自己调用自己 return n * arguments.callee(n-1) &#125; console.log(f3(9)) // 4! // 4* f3(3)=4*3*f3(2)=4*3*2*f3(1)=4*3*2*1 定时器定时器 每隔一段时间执行一个方法参数1: 回调函数参数2: 时间 以ms为单位setInterval 属于异步执行：不会影响后续代码的执行，不会阻塞代码的 var count = 1 var left1 = 0 setInterval(function()&#123; // 改背景颜色 // var a = Math.random()*255 // var b = Math.random()*255 // var c = Math.random()*255 // d1.style.backgroundColor=`rgb($&#123;a&#125;,$&#123;b&#125;,$&#123;c&#125;)` // 修改背景图片 // d1.style.backgroundImage = `url($&#123;count&#125;.webp)` // count++ // if(count&gt;=3)&#123; // count = 1 // &#125; // 修改位置平移 left1 = left1 + 10 d1.style.left = left1 + &#x27;px&#x27; &#125;,16.67) // 浏览器刷新频率是1s 60帧， 一帧的时间 1000/60 = 16.67ms // for属于同步任务，会阻塞代码执行 // for(var i = 0;i&lt;10000;i++)&#123; // console.log(&quot;222222&quot;) // &#125; // console.log(&quot;33333&quot;)","categories":[{"name":"web笔记","slug":"web笔记","permalink":"https://www.kassama.top/categories/web%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.kassama.top/tags/web/"},{"name":"HTML","slug":"HTML","permalink":"https://www.kassama.top/tags/HTML/"}]},{"title":"web学习笔记11 - 深浅拷贝","slug":"web学习笔记11","date":"2020-04-18T12:40:53.000Z","updated":"2022-09-19T12:55:37.729Z","comments":true,"path":"/webNotes11.html","link":"","permalink":"https://www.kassama.top/webNotes11.html","excerpt":"深浅拷贝 学习总结封面画师：唏嘘的星辰 p站ID：13312138","text":"深浅拷贝 学习总结封面画师：唏嘘的星辰 p站ID：13312138 栈空间和堆空间栈空间：一般基本数据类型存放在栈里面，栈类似于电梯结构，先进后出的特点堆空间： 一般引用类型存储在堆空间，严格来说，把变量保存在栈空间，把值保存在堆空间，堆类似于排队买饭，先进先出的特点 基本数据类型值传递在赋值的时候，把值本身复制一份，赋值给新变量，修改其中一个时候，另外一个不会变化，类似于复制和粘贴 var a = 10 var b = a //赋值 a = 20 // 修改a不会影响到b console.log(b) //10 复杂类型，引用类型 引用传递在赋值的时候，把指针复制一份，把复制的指针赋值给新变量，新旧指针指向的是同一个内存地址，这个俩个变量指向的是同一个数据，修改其中之一，另外一个会跟着修改 // 指针：指向内容的地址就是指针 var arr = [1,2,3] var arr1 = arr arr[0] = &quot;好&quot; console.log(arr1) // [&quot;好&quot;，2,3] 赋值封装基本数据类赋值场景：变量赋值，函数传参引用类型类赋值场景：变量赋值，函数传参 function f1(a)&#123; a = 10 console.log(a,&quot;------------&quot;) //10 &#125; var num1 = 200 f1(num1) //把实参赋值给形参 a=num1 console.log(num1,&quot;+++++++&quot;) //200 function f2(arr3)&#123; arr3[0]=&quot;好&quot; console.log(arr3,&quot;_____________&quot;) //[&quot;好&quot;,2,3] &#125; var newArray = [1,2,3] f2(newArray) // arr3 = newArray console.log(newArray,&quot;???????????&quot;)//[&quot;好&quot;,2,3] 深浅拷贝基本数据类型拷贝修改其中一个另外一个不会跟着变化 复杂数据类型拷贝深浅拷贝：仅限于引用类型的数据，(不严谨的说:值传递天生深拷贝)深拷贝： 修改其中一个另外一个不会受到影响浅拷贝： 修改其中一个另外一个会受到影响 出现场景直接赋值就是浅拷贝 实现深拷贝var obj = &#123; name:&#x27;zhangsna&#x27;, age:10, &#125; // 自己实现深拷贝的方式 把o拷贝一个新内存 // 没有实现多层拷贝 function deepCopy(o)&#123; var newO = &#123;&#125; //这个就是新内存 for (const key in o) &#123; // 遍历o对象所有属性和属性值添加到新对象里面 newO[key] = o[key] // newO[&quot;name&quot;] = zhangsan newO[&quot;age&quot;] = 10 &#125; return newO &#125; var n1 = deepCopy(obj) obj.name = &quot;张三&quot; // n1 没有受到该句的影响 console.log(n1,obj) 使用json的相关的API进行深拷贝var o1 = &#123; name:&quot;11&quot;, age:10, study:&#123; book:&quot;前端页面开发&quot; &#125; &#125; 对o1进行转成字符串var s1 = JSON.stringify(o1)console.log(s1) 再对字符串进行转成对象var o2 = JSON.parse(s1) 修改o1 看看是否影响到o2o1.study.book = &quot;java&quot;console.log(o1,o2) // 不会影响 完整深拷贝// 深拷贝 var obj = &#123; name:&quot;zs&quot;, age:10, gf:&#123; name:&quot;lis&quot;, age:18 &#125; &#125; // typeof 10 ==number // typeof &quot;1&quot; == string // typeof &#123;&#125; == object // typeof [] == object console.log(typeof []) //思路：先创建一个空对象，遍历源对象每一层把每一层的属性拷贝到新对象里面 function deepCopy(o)&#123; // 如果o是对象创建空对象，如果o是数组创建一个空数组 // Array.isArray(o) 判断o是不是一个数组 var newObj = Array.isArray(o)?[]:&#123;&#125; if(o &amp;&amp; typeof o ==&#x27;object&#x27;)&#123; // 如果o存在，并且o的typeof值是object // 遍历o对象 for (const key in o) &#123; // 判断对象是否key 如果存在取值 if (Object.hasOwnProperty.call(o, key)) &#123; const element = o[key]; // 取出对应属性值 // newObj[key] = element// 对新对象添加属性和属性值 //element 有可能是引用类型 例如gf字段 if(element &amp;&amp; typeof element ==&quot;object&quot;) &#123; // 如果属性值是对象类型 newObj[key] = deepCopy(element) &#125; else&#123; // 如果属性值是基本类型 newObj[key] = element &#125; &#125; &#125; &#125; return newObj &#125; var o3 = deepCopy(obj) obj.gf.age = 30 console.log(o3)","categories":[{"name":"web笔记","slug":"web笔记","permalink":"https://www.kassama.top/categories/web%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.kassama.top/tags/web/"},{"name":"HTML","slug":"HTML","permalink":"https://www.kassama.top/tags/HTML/"}]},{"title":"web学习笔记10 - 对象","slug":"web学习笔记10","date":"2020-04-16T14:20:43.000Z","updated":"2022-09-19T12:55:37.726Z","comments":true,"path":"/webNotes10.html","link":"","permalink":"https://www.kassama.top/webNotes10.html","excerpt":"对象 学习总结封面画师：唏嘘的星辰 p站ID：13312138","text":"对象 学习总结封面画师：唏嘘的星辰 p站ID：13312138 对象类：具有相同属性和方法的集合对象:类的实例化，类的具体化，对象可以把一个整体的属性进行集合保存， var obj = &#123;&#125; // 空对象 var zhangsan = &#123; &quot;name&quot;: &quot;张三&quot;, //属性 属性值也可以称为键值对(key value) age: 10, eat: function () &#123; console.log(this.name + &quot;吃饭&quot;) &#125; //方法 &#125; 访问方式 访问方式 对象.属性进行访问 console.log(zhangsan.name) //对象.属性进行访问 zhangsan.eat() //对象方法的调用 如果在方法使用this,this是就是该对象 console.log(this) //在script标签打印this，this是window对象 function f1() &#123; console.log(this) // this是window对象 &#125; window.f1() 访问方式 console.log(zhangsan[&#x27;name&#x27;]) //通过[属性名字符串格式]访问 var f1 = &quot;name&quot; console.log(zhangsan[f1]) //动态访问属性 console.log(zhangsan.name) // 静态访问属性 对象遍历 for…infor (const key in zhangsan) &#123; // hasOwnProperty() 判断对象里面有没有该属性， if (zhangsan.hasOwnProperty(key)) &#123; // console.log(key) // 对象里面属性 console.log(zhangsan[key]) //对象属性值 &#125; &#125; 如何给对象添加属性var lisi = &#123; name:&quot;李四&quot;, stuId:&quot;007&quot;, study:function()&#123; console.log(&quot;good good study day day up&quot;) &#125; &#125; lisi.age = 10 // 静态方式添加属性 lisi[&quot;sex&quot;] = true // 动态方式添加属性 lisi.name = &quot;四李&quot; //修改name属性值 delete lisi.name // 删除属性 console.log(lisi) for in &amp; for of使用for…of 遍历对象// for in 专门遍历对象 // for of 专门遍历数组 // .keys(lisi) 对象的所有的属性，数组结构 // .values(lisi) 对象的所有的属性值 console.log(Object.values(lisi),&quot;0000000000&quot;) for (const iterator of Object.keys(lisi)) &#123; console.log(iterator) //属性 console.log(lisi[iterator]) // 属性值 &#125; for…in 遍历数组var arr1 = [1,2,3] for(const a in arr1)&#123; console.log(a) //a就是索引值，把数组理解为属性为0 1 2的对象 console.log(arr1[a]) &#125; // for in 专门遍历对象, 也可以遍历数组 // for of 专门遍历数组, 也可以遍历对象","categories":[{"name":"web笔记","slug":"web笔记","permalink":"https://www.kassama.top/categories/web%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.kassama.top/tags/web/"},{"name":"HTML","slug":"HTML","permalink":"https://www.kassama.top/tags/HTML/"}]},{"title":"web学习笔记8 - 函数与作用域","slug":"web学习笔记8","date":"2020-04-15T13:20:12.000Z","updated":"2022-09-19T12:55:37.720Z","comments":true,"path":"/webNotes8.html","link":"","permalink":"https://www.kassama.top/webNotes8.html","excerpt":"函数与作用域 学习总结封面画师：唏嘘的星辰 p站ID：13312138","text":"函数与作用域 学习总结封面画师：唏嘘的星辰 p站ID：13312138 函数面向对象三大特点: 继承 多态 封装，函数: 代码集合体，把相同功能代码封装到一个函数体里面，以后这个函数重复使用了， 不带参数的函数封装// 关键字 函数名 (形参)&#123;函数体&#125; function add()&#123; var a = 10 var b = &quot;10&quot; var c = a+b //+ 加法运算，必须保证都是数字； // var c = a / b // 可以把字符串转成数字，然后再去计算 // var c = a * b // 把字符串转成数字一种方式，这种方式称为隐式转换 if(b)&#123; // 如果a数字， 非0都为true // 如果字符串 非&quot;&quot;都为true // 如果布尔值 true就是true， // 如果是空数组 为true // 如果是空对象 为true // 如果undefined 为false // null 不存在 为false console.log(c) &#125; &#125; // 必须调用:函数名() add() 递归引入// 1 1 2 3 5 8 13 21 function f1()&#123; console.log(&quot;f1&quot;) // too much recursion 函数体里面调用自己 造成死循环，需要合适的地方跳出，就是递归思想 // f1() &#125; f1() 带参数的函数封装// a,b,c 多个参数用逗号隔开，形参：在定义的时候没值 function f2(a,b,c)&#123; console.log(&quot;我的名字是&quot;+a+&quot;年龄是&quot;+b+&quot;性别是&quot;+c) &#125; f2(&quot;张三&quot;,10,&quot;男&quot;) // &quot;张三&quot; 实参， 函数调用的时候，把实参的赋值给形参 带默认参数的函数的封装带默认参数的函数的封装，把默认参数写在最后一位 function f3(name,stuid,sex=&quot;男&quot;)&#123; console.log(&quot;我的名字是&quot;+name+&quot;性别是&quot;+sex+&quot;学号是&quot;+stuid) &#125; f3(&quot;李四&quot;,&quot;001&quot;) //如果给默认参数传值了，默认参数就是传递的数据，如果不传值，默认参数就是默认值 f3(&quot;张三&quot;,&quot;002&quot;,&quot;女&quot;) f3(&quot;张三&quot;,&quot;男&quot;,&quot;003&quot;) 有返回值的函数有返回值的函数，必须带关键字return function f4(a,b,c)&#123; return a * b *c &#125; var aa = f4(10,10,10) console.log(aa) 作用域 全局作用域: 在script标签定义的变量。就是一个全局变量，可以在任何地方去使用。 局部作用域: 在函数体定义的变量，就是一个局部变量，只能用在当前的函数体中 块级作用域: 在代码块{}定义的变量，采用let进行定义，只能用在当前代码块里面var a = 10 //全局的变量 function f1()&#123; console.log(a) &#125; f1() //var 变量提升只会把变量声明提升到当前作用域最前面 function f2()&#123; console.log(b,&quot;--------&quot;) var b = 10 //局部变量 console.log(b,&quot;--------&quot;) &#125; f2() // console.log(b) // 局部变量只能用在定义函数体里面 // 当全局变量和局部的变量如果冲突了，在局部作用域使用的是局部的变量， // 在全局里面使用的全局变量 function f3()&#123; var a = 20 console.log(a,&quot;++++++++&quot;) &#125; f3() console.log(a,&quot;--------------&quot;) /* 1 全局的用起来比较方便 只需要定义一次,全局变量不会被释放,一直占用内存空间 2 局部的变量不能在函数体使用,当函数体执行完了,局部的变量就会直接被释放, */ //在局部定义变量如何间接使用在全局里面 function f4(e,f)&#123; var d = 100 // 局部 return d &#125; var f = f4() console.log(f) 作用域链访问一个变量,按照作用域链进行访问,当访问一个变量,先当前作用域去找,如果找到了,就直接使用,如果没找到,去父级作用域去找,如果父级作用域没有,去他父级的父级作用域去找,直到找到全局作用域为止,这样就形成一个作用域链 var a = 100 function f2() &#123; var a = 30 function f3() &#123; var a = 20 function f4() &#123; var a = 10 console.log(a, &quot;++++++&quot;) //10 &#125; f4() console.log(a, &quot;-------&quot;) //20 &#125; f3() console.log(a, &quot;????????&quot;) // 30 &#125; f2() console.log(a) //100","categories":[{"name":"web笔记","slug":"web笔记","permalink":"https://www.kassama.top/categories/web%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.kassama.top/tags/web/"},{"name":"HTML","slug":"HTML","permalink":"https://www.kassama.top/tags/HTML/"}]},{"title":"web学习笔记9 - 字符串","slug":"web学习笔记9","date":"2020-04-15T13:20:12.000Z","updated":"2022-09-19T12:55:37.723Z","comments":true,"path":"/webNotes9.html","link":"","permalink":"https://www.kassama.top/webNotes9.html","excerpt":"字符串 学习总结封面画师：唏嘘的星辰 p站ID：13312138","text":"字符串 学习总结封面画师：唏嘘的星辰 p站ID：13312138 创建字符串字面量创建&quot;&quot; 不能嵌入双引号，可以嵌入单引号 可以\\n进行换行&#39;&#39; 不能嵌入单引号，可以嵌入双引号 可以\\n进行换行` ` es6字符串模板 可以支持换行显示特殊符号，需要使用\\进行转义var s1 = &#39;how\\&#39;re you ? \\n张三&#39;console.log(s1) 创建字符串对象方式var s2 = new String(&#39;蕾姆&#39;)console.log(s2) 字符串创建基本数据类型var s3 = String(&#39;蕾姆酱天下第一&#39;)console.log(s3) 字符串拼接concat() 拼接var str1 = &quot;hello&quot; var str2 = &quot;world&quot; var str3 = &quot;!&quot; console.log(str1+str2+str3) console.log(`$&#123;str1&#125;$&#123;str2&#125;$&#123;str3&#125;`) console.log(str1.concat(str2,str3)) console.log(str1.length) //字符串长度 console.log(str1[0]) //通过索引值取 for循环遍历for(var i = 0;i&lt;str1.length;i++)&#123; var char = str1[i] console.log(char) &#125; // es6专门提供一个遍历数组的方式 for...of... for (const iterator of str1) &#123; console.log(iterator) &#125; 字符串转成数字的方式var str4 = &quot;10px&quot; // 10*1 console.log(str4*1) //NAN //parseFloat前提以数字开头的字符串，可以转成数字 console.log(parseFloat(str4)) //10 var a = 10.535 console.log(a.toFixed(2)) // 数字对象toFixed(2) 保留小数 .trim()去掉头部和尾部的空格符号var str5 = d1.textContent.trim() 封装函数根据传入字符，从指定字符串选取出来，加以显示高亮c 代表是高亮的字符all 代表整个字符 未封装函数var htmlStr = &#x27;&#x27; for(var i = 0;i&lt;str5.length;i++)&#123; if(str5[i]==&quot;逮&quot;)&#123; // 把了替换成span htmlStr += `&lt;span style=&#x27;background-color:red&#x27;&gt;$&#123;str5[i]&#125;&lt;/span&gt;` &#125;else&#123; // 把不相等也得拼接上 htmlStr+=str5[i] &#125; &#125; d1.innerHTML = htmlStr 封装函数var htmlStr = &#x27;&#x27; // 封装函数：先考虑要不要传参, 在考虑函数要不要有返回值 function getStr(c,all)&#123; for(var i = 0;i&lt;all.length;i++)&#123; if(all[i]==c)&#123; // 把了替换成span htmlStr += `&lt;span style=&#x27;background-color:red&#x27;&gt;$&#123;all[i]&#125;&lt;/span&gt;` &#125;else&#123; // 把不相等也得拼接上 htmlStr+=all[i] &#125; &#125; &#125; getStr(&#x27;男&#x27;,str5) d1.innerHTML = htmlStr 大小写转换var s1 = &quot;abcdEFG&quot; console.log(s1.toLocaleUpperCase()) // 转成大写的 console.log(s1.toLocaleLowerCase())// 转成小写的 字母与ASCII的转换var s2 =&quot;abc&quot; console.log(s2.charAt(0)) // a 索引值所对应的字符 console.log(s2.charCodeAt(0))//97 索引值所对应的字符的ASCII码 console.log(&quot;Z&quot;.charCodeAt(0)) // 65 var a = &quot;9&quot; if(a.charCodeAt(0)&gt;=65 &amp;&amp; a.charCodeAt(0)&lt;=90)&#123; console.log(&quot;大写字母&quot;) &#125; console.log(&quot;0&quot;.charCodeAt(0)) //48 console.log(&quot;9&quot;.charCodeAt(0)) //57 console.log(String.fromCharCode(97)) //a 把ASCII转成对应字符 判断字符是否以…开头var s3 = &quot;my heart will go on&quot; // console.log(s3.startsWith(&#x27;my&#x27;)) //true console.log(s3.endsWith(&#x27;my&#x27;)) // 判断字符是否以...结尾 false console.log(s3.startsWith(&#x27;my heart will go on&#x27;)) console.log(s3.endsWith(&#x27;my heart will go on&#x27;)) indexOf 获取一个字符的下标 重点var s4 = &quot;abca&quot; console.log(s4.indexOf(&quot;a&quot;)) //0 console.log(s4.lastIndexOf(&quot;a&quot;))//3 console.log(&quot;-&quot;.repeat(20)) // -重复20次 字符串替换replace() 只替换一个replaceAll() 替换所有的如果一个方法调用完之后得到是一个字符串，还可以再次调用其他字符串API ,这样就形成一个链式调用 var s5 = &quot;hello world&quot; console.log(s5.replace(&quot;l&quot;,&quot;L&quot;).replace(&quot;l&quot;,&quot;L&quot;)) console.log(s5.replace(&quot;l&quot;,&#x27;&lt;span&gt;L&lt;/span&gt;&#x27;)) //把第二个字符串替换掉第一个字符， console.log(s5.replace(&quot;l&quot;,&#x27;&lt;span style=&quot;color:red&quot;&gt;L&lt;/span&gt;&#x27;).replace(&quot;l&quot;,&#x27;&lt;span style=&quot;color:red&quot;&gt;L&lt;/span&gt;&#x27;)) console.log(s5.replaceAll(&quot;l&quot;,&quot;L&quot;)) //替换全部 截取子字符串 （重点）var s6 = &quot;abcdefg&quot; console.log(s6.substring(1,3)) //从第一个开始 到第二个结束 bc console.log(s6.substring(1))//截取到最后 console.log(s6.substr(1,3))//从索引值1开始 截取的长度为3位 bcd 去掉空格符号（了解）var s7 &#x3D; “ hello world “console.log(s7.trim()) &#x2F;&#x2F; 去掉前后空格console.log(“ hello world “.trimStart()) &#x2F;&#x2F;去掉开始空格console.log(“ hello world “.trimRight())&#x2F;&#x2F;去掉右边空格 字符串数组的转换（重点）var s8 = &quot;http：//1.jpg;http：//2.jpg;http：//3.jpg&quot; var arr = s8.split(&quot;;&quot;) //安装某个字符进行分割，不加参数把字符串每一个字符进行分割 // 带参数，把参数后面和前面分割成数组的元素 console.log(arr) var s9 = &quot;1234321&quot; var arr1 = s9.split(&quot;&quot;).reverse() var s10 = arr1.join(&quot;&quot;) //数组转成字符串 if(s10==s9)&#123; console.log(&quot;是倒序数&quot;) &#125; 三元运算&#x2F;三目运算var b = 10 var b1 = b&gt;20?&quot;成年&quot;:&quot;未成年&quot; // 如果前面条件成立，结果为？后面的，如果不成立，结果为冒号后面 console.log(b1) 三个数取最大值var b2 = 20 var b3 = 40 var b4 = 30 var max = b2&gt;b3?b2:b3 // max就是b2和b3最大值 max = max&gt;b4?max:b4 var date=new Date().getDate()","categories":[{"name":"web笔记","slug":"web笔记","permalink":"https://www.kassama.top/categories/web%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.kassama.top/tags/web/"},{"name":"HTML","slug":"HTML","permalink":"https://www.kassama.top/tags/HTML/"}]},{"title":"web学习笔记7 - 数组","slug":"web学习笔记7","date":"2020-04-13T11:50:21.000Z","updated":"2022-09-19T12:55:37.717Z","comments":true,"path":"/webNotes7.html","link":"","permalink":"https://www.kassama.top/webNotes7.html","excerpt":"数组 学习总结封面画师：唏嘘的星辰 p站ID：13312138","text":"数组 学习总结封面画师：唏嘘的星辰 p站ID：13312138 基础概念js：弱类型的编程语言，定义变量不清楚变量具体类型，赋值的时候才知道数据的类型，数组：用来存储数据元素的，可以存储的类型是任意的，访问数组元素通过索引值进行访问的，最大的索引值的和数组的长度相差1var arr = [&quot;张三&quot;,10] js推荐使用此种方式进行定义数组， 定义数组方式构造函数定义 参数是元素列表var p2 = new Array(&quot;hello&quot;,2,3) 定义指定长度的数组参数是数字类型(arrayLength?: number) 参数列表arrayLength 参数名? 可传可不传number 是数字类型 数组对象定义new Arrayvar p3 = new Array(10) new Array参数是数组结构相当于数组元素就是数组var p4 = new Array([&quot;1&quot;,2,3])二维数组调用方式console.log(p4[0][1]) &#x2F;&#x2F; 2 访问数组元素var arr = [&quot;张三&quot;,18]console.log(arr[0]) &#x2F;&#x2F;“张三”console.log(arr[3]) &#x2F;&#x2F; undefined 遍历数组遍历for(var i = 0;i&lt;arr.length;i++)&#123; console.log(arr[i]) &#125; 倒序遍历for(var i = arr.length-1;i&gt;=0;i--)&#123; console.log(arr[i],&quot;----------&quot;) &#125; 倒序遍历for(var i = 0;i&lt;arr.length;i++)&#123; console.log(arr[arr.length-1-i],&quot;++++++++++&quot;) &#125; 数组遍历的APIArray.forEach(callbackfn)参数名callbackfn：回调函数，必须是一个函数回调函数的参数就是分别是元素，索引值，数组本身 arr.forEach(function(v,i,a)&#123; console.log(v,&quot;元素&quot;) console.log(i,&quot;索引值&quot;) console.log(a,&quot;数组本身&quot;) &#125;) 数组的增删改查操作有些操作会影响数组内容本身：数组内方法有些操作不会影响数组内容本身:数组外方法 var numArray = [1,2,3,4,5,6] 添加的操作numArray.push(&quot;hello&quot;) 向数组最后一个添加元素numArray.unshift(&quot;hanmeimei&quot;) 向数组最前面一个添加元素 通过索引值进行添加numArray[8]=&quot;lilei&quot; 删除numArray.pop() 删除最后一位的 和push一对numArray.shift() 删除最前一位的 和unshift一对 修改numArray[0] = &quot;10&quot; 查询通过索引值访问， 遍历可以访问所有的元素console.log(numArray[index])numArray.forEach(v,i,a)&#123;&#125; 获取元素索引值 如果元素存在 获取的是元素的索引值，如果元素不存在获取的是-1console.log(numArray.indexOf(&quot;lilei&quot;)) findIndex()参数是一个函数，函数的参数：元素，索引，数组本身 var i1 = numArray.findIndex(function(v,i,a)&#123; // v == &quot;hello&quot; 比较，把v和&quot;hello&quot;相等的元素索引值获取 return v == &quot;hello&quot; &#125;) console.log(i1) //查找到返回坐标，未查找到返回-1 其他API字符串字符串可以理解成一个特殊数组,能够用一些数组的方法 var str = &quot;hello&quot; console.log(str.length) // 获取字符串长度 5 console.log(str[2]) //获取单个字符 l console.log(str.indexOf(&quot;o&quot;)) //某个字符索引 Array.from() - 1把数据转成数组结构, 参数字符串 var arr = Array.from(str) console.log(arr) Array.from() - 2参数1 也可以数组参数2 是回调函数,可以对参数1数组元素进行操作 总体方法用来返回值变化数组结构 var arr2 = Array.from([1,2,3],function(v)&#123; return v *3 // 对数组元素都乘以3返回新数组 &#125;) console.log(arr2) concat()数组进行合并 var arr3 = [4,5,6] var arr4 = [7,8,9] var arr5 = arr4.concat(arr3) every()参数是回调函数回调函数每个参数分别为元素 索引 数组 // 数组每一个元素都满足这个条件时候,整体结果就为true // return 后面添加一个条件 var arr6 = [7,4,4,6,8,8] var t1 = arr6.every(function(v,i,a)&#123; return v % 2==0 &#125;) console.log(t1) some()只要数组当中有一个满足条件的,结果为true var t2 = arr6.some((v,i,a)=&gt;&#123; return v%2==0 &#125;) console.log(t2) lastIndexOf()返回最后一个元素的索引值 var lastIndex = arr.lastIndexOf(3) console.log(lastIndex) filter() 过滤函数函数里面写过滤条件,把满足过滤条件的元素放进一个新数组里面 var a1 = arr.filter(function(v,i,a)&#123; return v % 2 != 0 &#125;) console.log(a1) map() 映射函数把元素按照映射条件进行放入新数组里面 var a2 = arr.map(function(v,i,a)&#123; return v*3 &#125;) console.log(a2) join()把数组转成字符串 var s1 = arr.join(&quot;,&quot;) console.log(s1) reverse()把数组的元素倒过来放进数组 var s2 = arr.reverse() console.log(s2) splice() 删除数组// 参数1 要操作元素的索引值 // 参数2 0添加的意思，不为0删除的个数 // 参数3 添加的时候，为添加的元素 var arr1 =[&quot;zs&quot;,&quot;ls&quot;,&quot;wc&quot;,&#x27;mh&#x27;] // arr1.splice(0,2) //删除 arr1.splice(2,0,&quot;wangwu&quot;) //在索引值为2地方添加了wangwu console.log(arr1) slice() 截取子数组// &quot;111dds.jpg&quot; var arr2 = [1,2,3,4,5] // 截取子数组，从索引值开始截取，截取到最后 // 参数有俩个时候 从第一个开始截取（包头），到第二个结束 console.log(arr2.slice(2,3)) console.log(arr2.slice(arr2.length-3)) 其他案例数组去重var arr1 = [1,1,1,true,true,true,false,&quot;hello&quot;,&#x27;hello&#x27;] // 不添加新数组的前提 // 拿数组每一个元素和他们后面元素进行对比 如果相等了 把后面元素删除，删除之后下标减一 /* function quChong1(arr)&#123; for(var i = 0;i&lt;arr.length;i++)&#123; for(var j = i+1;j&lt;arr.length;j++ )&#123; if(arr[i]==arr[j])&#123; arr.splice(j,1) j-- &#125; &#125; &#125; return arr &#125; console.log(quChong1(arr1)) */ // 定义一个新数组，遍历原先数组，判断新数组有没有原先数组的元素，如果有，就不添加，如果没有，添加新数组里面 function quChong2(arr)&#123; var newArray = [] // find() 遍历函数， 找到满足遍历条件的元素的值,如果有，result就是这个值，如果没有，result就是undefined for(var i = 0;i&lt;arr.length;i++)&#123; var result = newArray.find(function(v)&#123; return v == arr[i] &#125;) if(result==undefined)&#123; newArray.push(arr[i]) &#125; &#125; return newArray &#125; console.log(quChong2(arr1)) 简单的注册登录数组d // 注册账号数组 var registerArray = [&quot;sj123456&quot;,&quot;gh123456&quot;,&quot;xzy123456&quot;] var use = &quot;xzy123456&quot; var t3 = registerArray.some(function(v,i,a)&#123; return v == use &#125;) if(t3)&#123; console.log(&quot;该账号已被注册&quot;) &#125;else&#123; console.log(&quot;恭喜注册成功了&quot;) &#125; // 账号密码 // 判断登录成功与否 var userArray = [&#123;user:&quot;13653858031&quot;,psw:&quot;123456&quot;&#125;,&#123;user:&quot;10086&quot;,psw:&quot;123456&quot;&#125;,&#123;user:&quot;10000&quot;,psw:&quot;123456&quot;&#125;,&#123;user:&quot;10010&quot;,psw:&quot;123456&quot;&#125;] var user = &quot;10000&quot; var psw = &quot;123456&quot; var t4 = userArray.some(function(v,i,a)&#123; // v对象 return v.user==user&amp;&amp;v.psw == psw &#125;) if(t4)&#123; alert(&quot;登录成功&quot;) &#125;else&#123; alert(&quot;账号或者密码错误&quot;) &#125;d 冒泡排序&#x2F;&#x2F; 实现俩个数字交换位置&#x2F;&#x2F; 定义中间变量var a &#x3D; 10var b &#x3D; 20 &#x2F;* var temp &#x3D; a &#x2F;&#x2F; 把a的值赋值给temp a &#x3D; b &#x2F;&#x2F;a &#x3D; 20 b &#x3D; temp &#x2F;&#x2F; 10 console.log(a,b) &#x2F;&#x2F; 20 10*&#x2F; &#x2F;&#x2F;不使用中间变量 实现数字交换&#x2F;&#x2F; b &#x3D; a - b&#x2F;&#x2F; a &#x3D; a - b &#x2F;&#x2F; a &#x3D; a-(a-b)&#x3D;b&#x2F;&#x2F; b &#x3D; a + b &#x2F;&#x2F; a-b+b &#x3D;a&#x2F;&#x2F; console.log(a,b) &#x2F;&#x2F; 冒泡：把数组元素从小到大进行排序，var arr &#x3D; [ 1,3,9,20,11,2,5] &#x2F;&#x2F; 外循环是经过多少次循环，每次循环找出一个最值&#x2F;&#x2F; 内循环是比较的次数 ,如果前面数比后面大，交换位置&#x2F;&#x2F; 未优化之前的写法 &#x2F;*for(var i &#x3D; 0;i&lt;arr.length;i++){ for(var j &#x3D; 0;j&lt;arr.length;j++){ if(arr[j]&gt;arr[j+1]){ var temp &#x3D; arr[j] &#x2F;&#x2F; 把大值赋值给temp arr[j] &#x3D; arr[j+1] &#x2F;&#x2F;把小值提到前面元素上 }}console.log(arr)*&#x2F; &#x2F;&#x2F; 外循环是经过多少次循环，每次循环找出一个最值 当i&#x3D;0 找一个最值 ; 当i&#x3D;1 找一个最值&#x2F;&#x2F; 7个数 其实经过6次找出6个最值 &#x2F;&#x2F; 内循环 第一轮已经找到一个最值，以后比较没有必要再和最值进行相比，for(var i &#x3D; 0;i&lt;arr.length-1;i++){ for(var j &#x3D; 0;j&lt;arr.length-1-i;j++){ if(arr[j]&gt;arr[j+1]){ var temp &#x3D; arr[j] &#x2F;&#x2F; 把大值赋值给temp arr[j] &#x3D; arr[j+1] &#x2F;&#x2F;把小值提到前面元素上 arr[j+1] &#x3D; temp &#x2F;&#x2F; 把大值放大后面元素 } }}console.log(arr) arr[j+1] &#x3D; temp &#x2F;&#x2F; 把大值放大后面元素 }","categories":[{"name":"web笔记","slug":"web笔记","permalink":"https://www.kassama.top/categories/web%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.kassama.top/tags/web/"},{"name":"HTML","slug":"HTML","permalink":"https://www.kassama.top/tags/HTML/"}]},{"title":"web学习笔记6 - Math和Date","slug":"web学习笔记6","date":"2020-04-11T08:37:58.000Z","updated":"2022-09-19T12:55:37.714Z","comments":true,"path":"/webNotes6.html","link":"","permalink":"https://www.kassama.top/webNotes6.html","excerpt":"Math和Date 学习总结封面画师：唏嘘的星辰 p站ID：13312138","text":"Math和Date 学习总结封面画师：唏嘘的星辰 p站ID：13312138 Math对象Math对象API向下求整var n1 = Math.floor(4.9)console.log(n1) // 4 向上求整var n2 = Math.ceil(4.1)console.log(n2) // 5 四舍五入var n3 = Math.round(4.5)console.log(n3) // 5 随机数 [0,1) 包前不包尾var n4 = Math.random() 日期对象创建日期对象:通过new Date()创建new 创建一个新的， 申请内存空间的作用存储日期对象Date() 构造函数：用来创建对象的， 函数名首先字母是大写var now = new Date()console.log(now) 创建日期对象 Date带参数，参数是字符串时间，把参数转成对象格式var before = new Date(&quot;2020-04-11 13:14:00&quot;)console.log(before) 创建日期字符串var s1 = Date()console.log(s1) 对象与字符串日期对象 例如now.getFullYear() 2020console.log(now.getFullYear()) 获取年的 2020console.log(s1.getFullYear()) s1.getFullYear is not a functionconsole.log(now.getMonth()+1) 获取月份之后加1console.log(now.getDate()) 获取日期console.log(now.getHours()) 获取小时console.log(now.getMinutes()) 获取分钟console.log(now.getSeconds()) 获取秒console.log(now.getDay()) 星期几，星期天是0console.log(now.getMilliseconds()) 获取ms数 1s&#x3D;1000ms Date是js内置对象now() 获取当前时间距离1970年1月1日的ms数 时间戳var d1 = Date.now()console.log(d1) 1586582040 把日期字符串转成时间ms数var d2 = Date.parse(&quot;2020-04-11 15:32:30&quot;)console.log(d2) 如何把ms转成日期对象把d1 = 1586582040转成年月日var d1 = 1586582040var n2 = new Date(d1)console.log(n2)console.log(n2.getFullYear()) &#x2F;&#x2F;2020console.log(n2.getMonth()+1) 把日期对象转成字符串console.log(n2.toDateString()) 只保留年月日字符串console.log(n2.toString()) 转成字符串(重要)console.log(n2.toTimeString()) 只保留时间 年月日时分秒getFullYear() 年getMonth()+1 月getDate() 日getHours() 时getMinutes() 分getSeconds() 秒getDay() 星期getMilliseconds() 毫秒 Date.now() 获取当前时间ms数Date.parse(&quot;2020-04-11 13:14:00&quot;) 获取当前时间ms数 实战练习5-20之间的随机数// [5,20)之间的随机数 // 5-20 5-5 - 20-5 =&gt; 0-15=&gt; // Math.random()*15 [0-15) // Math.floor(Math.random()*15) [0,14] // [0,14] + 5 =&gt; [5,20) var n5 = Math.floor(Math.random()*15)+5 console.log(n5) 九九乘法表// 1*1 = 1 // 2*1 = 2 2*2 = 4 // 3*1 =3 3*2=6 3*3 = 9 // 9*1=9 9*9 = 81 for(var i = 1;i&lt;10;i++)&#123; // i = 1-9 当成乘数 for(var j = 1;j&lt;=i;j++)&#123; // j = 当成被乘数 // 如果i = 1 j= 1 // 如果i=2 j = 1 2 document.write(`$&#123;i&#125;*$&#123;j&#125;=$&#123;i*j&#125;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;`) // document.write(i+&quot;*&quot;+j+&quot;=&quot;+i*j) &#125; document.write(&quot;&lt;br&gt;&quot;) &#125; 扩展了解// 扩展了解 // Math.PI π 90度 = Math.PI / 2 // sin 正弦 sin90度 = 1 cos0度 = 1 sin0度= 0 cos90度=0 // tan45度= 1 cot45度=1 console.log( Math.sin(90)) // 1 console.log(Math.cos(Math.PI/4)) // 0.7 console.log(Math.sqrt(9)) // 3 Math.sqrt()开平方 console.log(Math.abs(-3)) // 3 绝对值 console.log(Math.pow(3,2)) // 9 第一个数的多少次方 console.log(Math.pow(3,5))//243 Math.floor() Math.ceil() Math.round() Math.random() Math.pow(2,3) = 2^3 Math.pow(4,1/2) = 2 Math.PI Math.sqrt(9) = 3 Math.abs(-3) = 3 百钱买百鸡/* 百钱买百鸡 公鸡 一个5块钱 x=0 x=0 x=0 母鸡 一个3块钱 y=0 y=0 y = 小鸡 三个一块钱 z=0 z= 1 z =0 */ // 公鸡的个数0-100 for(var x = 0;x&lt;=100;x++)&#123; // 母鸡的个数0-100 for(var j=0;j&lt;=100;j++)&#123; // 小鸡的个数0-100 for(var z = 0;z&lt;=100;z++)&#123; var c1 = (x+j+z==100) var c2 = (5*x+3*j+z/3==100) var c3 = (z%3==0) if(c1&amp;&amp;c2&amp;&amp;c3)&#123; console.log(`公鸡的个数为:$&#123;x&#125;;母鸡的个数为:$&#123;j&#125;;小鸡的个数为:$&#123;z&#125;`) &#125; &#125; &#125; &#125;","categories":[{"name":"web笔记","slug":"web笔记","permalink":"https://www.kassama.top/categories/web%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.kassama.top/tags/web/"},{"name":"HTML","slug":"HTML","permalink":"https://www.kassama.top/tags/HTML/"}]},{"title":"web学记笔记5 - js循环3","slug":"web学习笔记5","date":"2020-04-08T14:10:32.000Z","updated":"2022-09-19T12:55:37.711Z","comments":true,"path":"/webNotes5.html","link":"","permalink":"https://www.kassama.top/webNotes5.html","excerpt":"js循环3 学习总结封面画师：唏嘘的星辰 p站ID：13312138","text":"js循环3 学习总结封面画师：唏嘘的星辰 p站ID：13312138 for循环嵌套案例1先执行 var i = 0; 判断 i &lt; 10,成立再去执行内部的循环，先去执行 var j = 0 ，再去判断 j &lt; 10 ,如果成立，去执行内部循环体，再去执行j++ ，再去判断是否小于10，如果小于10，在执行内部循环，直到j不小于10，最后执行i++ i 和 j 值的变化 i j 0 0 1 2 3 4 5 6 7 8 9 1 0 1 2 3 4 5 6 7 8 9 2 0 1 2 3 4 5 6 7 8 9 … 9 0 1 2 3 4 5 6 7 8 9 // 外循环 for(var i = 0;i&lt;10;i++)&#123; // console.log(i) //0-9 // 内循环 for(var j=0;j&lt;10;j++)&#123; // i=0;j=0 // console.log(&quot;i=&quot; + i + &quot;;j=&quot; + j) console.log(`i=$&#123;i&#125;;j=$&#123;j&#125;`) &#125; &#125; 案例2for(var i= 0;i&lt;5;i++)&#123; // break 跳出离他最近的循环嵌套 for(var j = 0;j&lt;5;j++)&#123; console.log(i,j) break &#125; &#125; // i = 0 j = 0 // i = 1 j = 0 // i = 2 j = 0 // i = 3 j = 0 // i = 4 j = 0 案例3for (var i = 0; i &lt; 3; i++) &#123; // break 跳出离他最近的循环嵌套 for (var j = 0; j &lt; 3; j++) &#123; console.log(i, j) if(j&lt;2)&#123; break &#125; &#125; &#125; /* i = 0 j=0 i = 1 j= 0 i = 2 j = 0 */ 案例4for(var i = 0;i&lt;3;i++)&#123; for(var j = 0;j&lt;3;j++)&#123; if(j==2)&#123; break &#125; console.log(j,&quot;--------------------&quot;) //打印几次 分别多少 // 0 1 &#125; console.log(i,&quot;+++++++++++++++++++++++++&quot;)//打印几次 分别多少 0 1 2 &#125; /* i = 0 j = 0 1 i = 0 i = 1 j=0 1 i = 1 i=2 j=0 1 i = 2 */ 数据分析案例1 （弹性布局） &lt;style&gt; #main&#123; width: 1200px; margin: 0 auto; /* 弹性布局 */ display: flex; /* 水平的排版方式 space-around：周围有空间*/ /* space-between 俩者之间有间距 */ justify-content:space-between; /* 换行 */ flex-wrap: wrap; border: 1px solid red; &#125; #main .item&#123; width: 250px; padding: 10px; &#125; #main img&#123; width: 100%; height: 200px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;main&quot;&gt; &lt;/div&gt; &lt;script src=&quot;腾发.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var 车数组 = data.data.content console.log(车数组) var s1 = &quot;&quot; for(var i = 0;i&lt;车数组.length;i++)&#123; var 车 = 车数组[i] var p = &quot;&quot; if(车.saleType==2)&#123; p = `&lt;p class=&#x27;c1&#x27;&gt;限时特惠&lt;/p&gt;` &#125;else&#123; p = `&lt;p class=&#x27;c2&#x27;&gt;腾发自营&lt;/p&gt;` &#125; s1 = s1 + ` &lt;div class=&quot;item&quot;&gt; &lt;img src=$&#123;车.cover&#125; alt=&quot;&quot;&gt; $&#123;p&#125; &lt;p class=&quot;title&quot;&gt;$&#123;车.carName&#125;&lt;/p&gt; &lt;p class=&quot;time&quot;&gt;$&#123;车.dateOfRegistration&#125; $&#123;车.mileage&#125;&lt;/p&gt; &lt;p class=&quot;price&quot;&gt;$&#123;车.currentPrice&#125;&lt;/p&gt; &lt;/div&gt; ` &#125; main.innerHTML = s1 console.log(s1) &lt;/script&gt; &lt;/body&gt; JS文件（因篇幅问题，部分数据已被删减）： var data = &#123; &quot;status&quot;: 200, &quot;success&quot;: true, &quot;msg&quot;: &quot;操作成功&quot;, &quot;data&quot;: &#123; &quot;totalElements&quot;: 3754, &quot;pages&quot;: 188, &quot;content&quot;: [ &#123; &quot;ind&quot;: &quot;202107151725080963&quot;, &quot;carName&quot;: &quot;2019款 揽胜星脉(进口) 250PS&quot;, &quot;dateOfRegistration&quot;: 1546272000000, &quot;currentPrice&quot;: 40.9, &quot;mileage&quot;: 3.16, &quot;saleType&quot;: 2, &quot;cover&quot;: &quot;https://tfcar.oss-cn-hangzhou.aliyuncs.com/257819713441103872.jpg?x-oss-process=style/watermark&quot;, &quot;reportAssess&quot;: true &#125;, &#123; &quot;ind&quot;: &quot;202105231822590022&quot;, &quot;carName&quot;: &quot;2003款 陆地巡洋舰 4.5L 手动 GX&quot;, &quot;dateOfRegistration&quot;: 1075564800000, &quot;currentPrice&quot;: 9.9, &quot;mileage&quot;: 30.16, &quot;saleType&quot;: 2, &quot;cover&quot;: &quot;https://tfcar.oss-cn-hangzhou.aliyuncs.com/227801833416949760.jpg?x-oss-process=style/watermark&quot;, &quot;reportAssess&quot;: true &#125;, &#123; &quot;ind&quot;: &quot;202106211755020723&quot;, &quot;carName&quot;: &quot;2014款 起亚K5 2.0L 手动 GL&quot;, &quot;dateOfRegistration&quot;: 1404144000000, &quot;currentPrice&quot;: 4.9, &quot;mileage&quot;: 10.31, &quot;saleType&quot;: 2, &quot;cover&quot;: &quot;https://tfcar.oss-cn-hangzhou.aliyuncs.com/270495116668436480.jpg?x-oss-process=style/watermark&quot;, &quot;reportAssess&quot;: true &#125;, &#123; &quot;ind&quot;: &quot;202107201459061126&quot;, &quot;carName&quot;: &quot;2011款 汉兰达 2.7L 自动 两驱豪华版 7座&quot;, &quot;dateOfRegistration&quot;: 1359648000000, &quot;currentPrice&quot;: 8.9, &quot;mileage&quot;: 13.52, &quot;saleType&quot;: 2, &quot;cover&quot;: &quot;https://tfcar.oss-cn-hangzhou.aliyuncs.com/275572024418500608.jpg?x-oss-process=style/watermark&quot;, &quot;reportAssess&quot;: true &#125;, &#123; &quot;ind&quot;: &quot;202106161151190127&quot;, &quot;carName&quot;: &quot;2007款 捷豹XJ(进口) XJ6L 新一代皇家加长版&quot;, &quot;dateOfRegistration&quot;: 1196438400000, &quot;currentPrice&quot;: 19.9, &quot;mileage&quot;: 16.68, &quot;saleType&quot;: 0, &quot;cover&quot;: &quot;https://tfcar.oss-cn-hangzhou.aliyuncs.com/278907000484528128.jpg?x-oss-process=style/watermark&quot;, &quot;reportAssess&quot;: true &#125;, &#123; &quot;ind&quot;: &quot;202107191448321079&quot;, &quot;carName&quot;: &quot;2015款 奔驰E级 改款 E180L 运动型&quot;, &quot;dateOfRegistration&quot;: 1451577600000, &quot;currentPrice&quot;: 19.9, &quot;mileage&quot;: 10.8, &quot;saleType&quot;: 0, &quot;cover&quot;: &quot;https://tfcar.oss-cn-hangzhou.aliyuncs.com/257802955825086464.jpg?x-oss-process=style/watermark&quot;, &quot;reportAssess&quot;: true &#125;, &#123; &quot;ind&quot;: &quot;202109231134445865&quot;, &quot;carName&quot;: &quot;2017款 别克GL8 25S 舒适型 国V&quot;, &quot;dateOfRegistration&quot;: 1509465600000, &quot;currentPrice&quot;: 16.59, &quot;mileage&quot;: 9.0, &quot;saleType&quot;: 0, &quot;cover&quot;: &quot;https://tfcar.oss-cn-hangzhou.aliyuncs.com/178107228115435520.jpeg?x-oss-process=style/watermark&quot;, &quot;reportAssess&quot;: false &#125;, &#123; &quot;ind&quot;: &quot;202106171618320442&quot;, &quot;carName&quot;: &quot;2017款 自由侠 180T 自动动能版+&quot;, &quot;dateOfRegistration&quot;: 1506787200000, &quot;currentPrice&quot;: 6.99, &quot;mileage&quot;: 8.0, &quot;saleType&quot;: 0, &quot;cover&quot;: &quot;https://tfcar.oss-cn-hangzhou.aliyuncs.com/275287714641739776.jpg?x-oss-process=style/watermark&quot;, &quot;reportAssess&quot;: true &#125;, &#123; &quot;ind&quot;: &quot;202108061724331343&quot;, &quot;carName&quot;: &quot;2014款 宝马5系 525Li 领先型&quot;, &quot;dateOfRegistration&quot;: 1427817600000, &quot;currentPrice&quot;: 20.9, &quot;mileage&quot;: 15.42, &quot;saleType&quot;: 2, &quot;cover&quot;: &quot;https://tfcar.oss-cn-hangzhou.aliyuncs.com/275570205638262784.jpg?x-oss-process=style/watermark&quot;, &quot;reportAssess&quot;: true &#125;, &#123; &quot;ind&quot;: &quot;202106161645460187&quot;, &quot;carName&quot;: &quot;2020款 威霆 2.0T 精英版 7座&quot;, &quot;dateOfRegistration&quot;: 1612108800000, &quot;currentPrice&quot;: 46.9, &quot;mileage&quot;: 0.08, &quot;saleType&quot;: 2, &quot;cover&quot;: &quot;https://tfcar.oss-cn-hangzhou.aliyuncs.com/275286122685267968.jpg?x-oss-process=style/watermark&quot;, &quot;reportAssess&quot;: true &#125;, &#123; &quot;ind&quot;: &quot;202106160917050115&quot;, &quot;carName&quot;: &quot;2013款 兰德酷路泽(进口) 4000 中东版&quot;, &quot;dateOfRegistration&quot;: 1420041600000, &quot;currentPrice&quot;: 43.9, &quot;mileage&quot;: 11.87, &quot;saleType&quot;: 2, &quot;cover&quot;: &quot;https://tfcar.oss-cn-hangzhou.aliyuncs.com/265569758785568768.jpg?x-oss-process=style/watermark&quot;, &quot;reportAssess&quot;: true &#125; ] &#125;, &quot;time&quot;: &quot;2022-07-08 15:03:25&quot; &#125;","categories":[{"name":"web笔记","slug":"web笔记","permalink":"https://www.kassama.top/categories/web%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.kassama.top/tags/web/"},{"name":"HTML","slug":"HTML","permalink":"https://www.kassama.top/tags/HTML/"}]},{"title":"web学习笔记4 - js基础2","slug":"web学习笔记4","date":"2020-04-03T12:44:07.000Z","updated":"2022-09-19T12:55:37.709Z","comments":true,"path":"/webNotes4.html","link":"","permalink":"https://www.kassama.top/webNotes4.html","excerpt":"js基础2 自学总结封面画师：唏嘘的星辰 p站ID：13312138","text":"js基础2 自学总结封面画师：唏嘘的星辰 p站ID：13312138 JS拼接 拼接的四种方法 拼接1：通过 + 进行拼接 拼接2： `${a}&#96; 拼接之后结果都是字符串和基本数据类型进行拼接 var a = 10 // 1 数字和字符串进行拼接 + var s1 = &quot;我的年龄是&quot;+ a + &quot;岁&quot; console.log(s1) // 2 es6字符串模板的写法$&#123;a&#125; 给a标量占位置的 var s2 = `我的年龄是$&#123;a&#125;岁，他的年龄也是$&#123;a&#125;岁` console.log(s2) // 把数字转成字符串的功能 可以是拼接进行转换 // 把字符串转化成数字 字符串必须数字字符串 var b = &quot;10&quot; // 1 直接*1, 先把b字符串转成数字，再乘以1，这种转换称为隐式转换 console.log(b*1) // 2 通过一些api进行转换属于强制转换（显式转换） parseInt() 转换成整型的， parseFloat() 转成浮点数 var c = parseInt(b) console.log(c) var a1 = &quot;10&quot; var a2 = 2 var a3 = (a1*1+a2) / a2 == &quot;6&quot; console.log(a3) var img1 = &quot;./pro-logo.jpg&quot; var img2 = &quot;./pro-logo2.jpg&quot; var p1 = &quot;钢筋结构1&quot; var p2 = &quot;钢筋结构2&quot; var htmlStr = ` &lt;div&gt; &lt;img src=$&#123;img1&#125; alt=&#x27;&#x27; &gt; &lt;p&gt;$&#123;p1&#125;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;img src=$&#123;img2&#125; alt=&#x27;&#x27; &gt; &lt;p&gt;$&#123;p2&#125;&lt;/p&gt; &lt;/div&gt; ` document.write(htmlStr) 原理：把之前的div标签写成一个字符串，通过for循环 可以拼接多个div，把多个div直接渲染在body里面 var s = &quot;&quot; for(var i = 0;i&lt;3;i++)&#123; s+= &lt;div&gt;&lt;/div&gt; &#125; console.log(s) // 输出：&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt; 显式转换和隐式转换显式转化 通过一些api进行转换 parseInt() parseFloat() parseInt() 把目标转化为整数型 parseFloat() 把目标转化为浮点型（小数型）隐式转换 “10” * 1 &#x3D; 10 “10”&#x2F;2 数组普通数组数组 用来存储数据的，每一个元素都是有索引值，通过该元素的索引值进行访问的，索引值从0开始，数组的个数从1开始。例如： var arr1 = [&quot;蕾姆&quot;,&quot;拉姆&quot;,&quot;塞尔达&quot;,&quot;林克&quot;,&quot;米法&quot;]arr1[0] 就是 “蕾姆” arr1[4] 就是 “米法” 数组遍历// 数组遍历 // array.length 数组的长度 for (var i = 0; i &lt; arr1.length; i++) &#123; var e = arr1[i]; console.log(e) &#125; 二维数组var arr = [[1,2,3],[&quot;安培死了&quot;,&quot;百度已经更新安培的年龄消息&quot;]] // 二维数组 var a1 = arr[1] // a1[0] 就是 &quot;安倍死了&quot; // arr[0][0] 就是 1 // arr [一维数组] [二维数组] [三维数组] 以此类推 for(var i = 0;i&lt;arr.length;i++)&#123; var e = arr[i] &#125; 对象对象 可以表示多个数据 ，多个数据是属于一个整体，对象 包含属性和方法属性值可以是任意类型 var obj = &#123; name: &quot;蕾姆&quot;, age: 18, cp:&#123; name: &quot;莱月卯&quot; &#125;, sister:&#123; name: &quot;拉姆&quot;, age: 18 &#125;, friend:[ &#123; name: &#x27;艾米利亚&#x27;, age: 20 &#125;, &#123; name: &#x27;路人甲A&#x27;, age: 18 &#125;, &#123; name: &#x27;路人乙B&#x27;, age: 16 &#125; ] &#125; console.log(obj.name) //对象如何访问属性 console.log(obj.son.name) console.log(obj.guinv[1].name) // 获取所有名字 for(var i = 0;i&lt;obj.guinv.length;i++)&#123; console.log(obj.guinv[i].name) &#125; 数据分析数据分析，遇见 &#123;&#125; 代表对象； 遇见 [] 代表数组;d1.innerHTML = &quot;&lt;h1&gt;M&lt;/h1&gt;&quot; 在d1插入html字符串 var data = [ &#123; id:1, //商品id // 图片url imgUrl:&quot;./img/pro-logo.jpg&quot;, info:&quot;厂家直销，不要999，只要99元&quot;, company:&quot;河南佰辰机械设备有限公司&quot;, tips:[&quot;诚&quot;,&quot;钻石版&quot;], price:60000 &#125;, &#123; id:2, //商品id // 图片url imgUrl:&quot;./img/pro-logo2.jpg&quot;, info:&quot;厂家直销，不要999，只要99元&quot;, company:&quot;河南佰辰机械设备有限公司&quot;, tips:[&quot;诚&quot;,&quot;钻石版&quot;], price:110000 &#125;, &#123; id:3, //商品id // 图片url imgUrl:&quot;./img/pro-logo.jpg&quot;, info:&quot;厂家直销，不要999，只要99元&quot;, company:&quot;河南佰辰机械设备有限公司&quot;, tips:[&quot;诚&quot;,&quot;钻石版&quot;], price:60000 &#125; ] var s = &quot;&quot; for(var i = 0;i&lt;data.length;i++)&#123; s+= `&lt;div class=&quot;c1&quot;&gt; &lt;img src=$&#123;data[i].imgUrl&#125; alt=&quot;&quot;&gt; &lt;p&gt;$&#123;data[i].info&#125;&lt;/p&gt; &lt;p&gt;$&#123;data[i].company&#125;&lt;/p&gt; &lt;p&gt;$&#123;data[i].price&#125;&lt;/p&gt; &lt;/div&gt;` &#125; // innerHTML 给元素添加一个html字符串 d1.innerHTML = s // document.write(s)","categories":[{"name":"web笔记","slug":"web笔记","permalink":"https://www.kassama.top/categories/web%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.kassama.top/tags/web/"},{"name":"HTML","slug":"HTML","permalink":"https://www.kassama.top/tags/HTML/"}]},{"title":"web学习笔记3 - Js基础1","slug":"web学习笔记3","date":"2020-03-28T12:35:00.000Z","updated":"2022-09-19T12:55:37.706Z","comments":true,"path":"/webNotes3.html","link":"","permalink":"https://www.kassama.top/webNotes3.html","excerpt":"Js基础1 自学总结封面画师：唏嘘的星辰 p站ID：13312138","text":"Js基础1 自学总结封面画师：唏嘘的星辰 p站ID：13312138 js更改样式&lt;div id=&quot;d1&quot;&gt;更改样式&lt;/div&gt; &lt;!-- onclick 当点击的时候， changeStyle() 点击执行changeStyle功能--&gt; &lt;button onclick=&quot;changeStyle()&quot;&gt;点击更改样式&lt;/button&gt; &lt;script&gt; // 定义函数 function changeStyle()&#123; // 1查找div元素 通过函数进行查找的 document 文档，getElementById() 通过id获取元素 // .style 添加行内样式 ; .color 字体颜色； // document.getElementById(&quot;d1&quot;).style.color=&quot;red&quot; // 2 如果标签设置了id，js可以简单通过id直接获取标签, document.getElementById (&quot;d1&quot;) 类似于 d1 d1.style.color=&quot;red&quot; &#125; &lt;/script&gt; 流程控制语句if : 条件控制语句switch...case : 条件控制语句for : 循环控制语句do...while : 循环语句while : 循环语句try...catch...finally : 语句用于处理代码中可能出现的错误信息 if判断 单独if条件 如果条件成了 执行{代码块} var age = 33 if (age&gt;40) &#123; console.log(&quot;大叔一枚&quot;) &#125; 多条件判断 = 赋值 ，name&#x3D;”刘能” 证明name是”刘能, 非空字符串作为if条件 这个时候成立的 == 比较相等的 === 恒等的 值和类型必须都一样 建议多条件判断不要使用if...if 弊端在于，每个if都会去判断，导致执行时间过长 var name = &quot;刘德华&quot; if(name==&quot;刘德华&quot;)&#123; console.log(&quot;能执行到不?&quot;) name = &quot;李嘉诚&quot; &#125; if(name==&quot;李嘉诚&quot;)&#123; console.log(&quot;帅哥一枚&quot;) &#125; if...else 如果…其他的… if...else... 只会判断一次 var score = 80 if(score&gt;60)&#123; console.log(&quot;我及格了&quot;) score = 59 &#125;else&#123; // 相当小于等于60 console.log(&quot;来年再战&quot;) &#125; 数字作为if条件，非0数字都是true都是成立，0未fasle 不成立的。 var a = 0 if(a)&#123; console.log(&#x27;33333333333333333333333&#x27;) &#125; if...else if...else score=80 if(score&gt;90)&#123; alert(&quot;优秀&quot;) &#125;else if(score&gt;=80&amp;&amp;score&lt;=90)&#123; alert(&quot;良好&quot;) &#125;else&#123; alert(&quot;还凑合&quot;) &#125; Switch语句// switch 开关 ()写判断的变量 // case season 的各种情况 var season = &quot;夏&quot; switch (season) &#123; case &quot;春&quot;: //如果season==&quot;春&quot; console.log(&quot;春天万物复苏&quot;) break; // 跳出当前判断 case &quot;夏&quot;: console.log(&quot;夏天烈日炎炎&quot;) break case &quot;秋&quot;: console.log(&quot;秋天硕果累累&quot;) break case &quot;冬&quot;: console.log(&quot;冬天白雪皑皑&quot;) break default: // 如果以上都不成立 执行default 默认 break; 运算符号// 符号 var a = 10 a = a + 10 // a=20 a = a - 10 // a = 10 a = a * 10 // a = 100 a = a / 10 // a = 10 // a = a / 3 // a 带小数 a = a % 3 // % 求余数 1 console.log(a) var b = 3 b+=3 // b = b+3 6 b*=8 //48 b*=8 b = b * 8 b/=3 //16 b%=3 // 1 console.log(b) // ++ 每次加1 ，c++ 等同于 c=c+1 等同于 c+=1 // -- 每次减1 // ++ 在前 本身先加1 ，再赋值 // ++在后 先赋值 本身再加1 var c = 30 var d = c++ // d =30 ,c=31 var e = ++c // c = 32 ,e=32 console.log(c,d,e) // 比较运算符号 console.log(3&gt;4) //false console.log(3&lt;=4) // true console.log(3==4) //false console.log(&quot;4&quot;==4) // true 把字符串4转成数字4 再进行比较 console.log(&quot;4&quot;===4) //false 恒等 数字和类型都得相等 console.log(3!=4) // true //逻辑运算符号 // &amp;&amp; 并且 多个条件必须同时成立 才为true // || 或者 只要有一个为true，整个条件都为true // ! 非 取反 console.log(true&amp;&amp;true) // true console.log(true&amp;&amp;false) //fasle console.log(3&gt;4&amp;&amp;true) //false console.log(true || false) //true console.log(1 &amp;&amp; 3&gt;4 ) //false console.log(!false) // true console.log(!1) //fasle console.log(!&quot;&quot;) //true for循环// var i = 0 循环初始值 // i&lt;10 循环条件 // i++ 每次i加1 // 先执行初始条件，再判断是否小于10，如果小于10，执行循环体，最后i的值再加1 for(var i = 0;i&lt;10;i++)&#123; console.log(i)//0-9 &#125; // 如果改变循环次数的时候 // 1 改循环条件 for(var i = 0;i&lt;5;i++)&#123; console.log(i) // 0-4 &#125; // 2 改循环初始值 for(var i = 5;i&lt;10;i++)&#123; console.log(i) // 5-9 &#125; // 3 改递增值 // i+2 表达式 没有赋值 // i+=2 i=i+2 把加的结果赋值给i for(var i = 0;i&lt;10;i+=2)&#123; console.log(i) // 0 2 4 6 8 &#125; // for非常规的操作1 for循环是同步执行的，执行完for之后才会往下执行，阻塞代码的执行 // for(var i = 0;i&lt;999999999;i++)&#123; // console.log(i) // &#125; // alert(10000) // 非常规的操作2 写成一个死循环 for(var i =0;i&lt;10;i--)&#123; console.log(i+&quot;-----------&quot;) // 0 -1 -2 -3 -4 if(i==-4)&#123; //当i==-4时候 执行break break // 跳出循环体 循环不在执行了 &#125; &#125; // 练习 // 3人 余2人; 5人 余4人；7人 余6人；9人 余8人;11人正好 问最少多少人？ // 0 1 2 3 for(var i =0;i&lt;9999;i++)&#123; if(i%3==2 &amp;&amp; i%5==4 &amp;&amp; i%7==6 &amp;&amp; i%9==8 &amp;&amp; i%11==0)&#123; console.log(i) //最少2519 &#125; &#125; do…whilefor(var i = 0;i&lt;3;i++)&#123;&#125; // 先判断 再执行 // while() 当条件成立了 执行&#123;&#125; var a = 0 while(a&lt;3)&#123; console.log(a,&quot;11111&quot;) a++ &#125; var b = 3 // 现执行再判断，最起码执行一次 do &#123; console.log(&quot;bbbbbbb&quot;) &#125; while (b&lt;3); // true 死循环 // while(1)&#123; // console.log(&quot;111111&quot;) // &#125; continue和breakcontine : 结束本次循环 执行下次循环breake : 跳出循环 /* for(var i = 0;i&lt;10;i++)&#123; console.log(i) //0-9 if(i&gt;5)&#123; continue // 结束本次循环，执行下次循环 &#125; &#125; for(var i = 0;i&lt;10;i++)&#123; if(i&gt;5)&#123; continue // 继续循环， 结束本次循环，执行下次循环 console.log(i,&quot;---------------&quot;) //没打印 &#125; &#125; for(var i = 0;i&lt;10;i++)&#123; if(i&gt;5)&#123; console.log(i,&quot;++++++++++&quot;) // 6 7 8 9 continue // 继续循环， 结束本次循环，执行下次循环 &#125; &#125; for(var i = 0;i&lt;10;i++)&#123; console.log(i,&quot;=======&quot;) // 0 1 2 3 4 5 6 7 8 9 if(i&lt;5)&#123; console.log(i,&quot;dddddddddddddddddddd&quot;) // 0 1 2 3 4 continue // 继续循环， 结束本次循环，执行下次循环 &#125; &#125; for(var i = 0;i&lt;10;i++)&#123; if(i&lt;5)&#123; continue // 继续循环， 结束本次循环，执行下次循环 &#125; console.log(i,&quot;????????????????????????????????????&quot;)//56789 &#125; */ for(var i = 0; i&lt;10;i++)&#123; console.log(i,&quot;jjjjjjjjjjjjjjjjj&quot;); // 0 break // 跳出循环 后面代码不执行 console.log(i,&quot;hhhhhhhhhhhhhhh&quot;) &#125; for(var i = 0;i&lt;10;i++)&#123; if(i&lt;5)&#123; console.log(&#x27;a&#x27;,i) // 0 1 2 3 4 continue &#125; if(i&gt;5)&#123; console.log(&quot;b&quot;,i) // 6 break &#125; console.log(&#x27;c&#x27;,i) //5 &#125; 运算符+ : 相加- :相减/ : 除以 带小数% : 求余数+= : i +&#x3D; 1 等同于 i &#x3D; i + 1-= : i -&#x3D; 1 等同于 i &#x3D; i - 1*= : i *&#x3D; 1 等同于 i &#x3D; i * 1/= : i &#x2F;&#x3D; 1 等同于 i &#x3D; i &#x2F; 1%= : i %&#x3D; 1 等同于 i &#x3D; i % 1 ++ 在前 先加后赋值 ； ++在后 先赋值在加1 ++i的结果var i = 10 var a = ++i a &#x3D; 11i &#x3D; 11 i++的结果var a = i++ a &#x3D; 10 i&#x3D;11 - -i 和 i- -也是一样 比较运算符号== 相等 （不比较数据类型，只比较值是否相等）=== 恒等 （比较数据类型和值是否相等） 逻辑运算符号&amp;&amp; 多个条件必须同时成立，才为true，否则为false|| 一个成立结果就是为true，否则为false! 取反","categories":[{"name":"web笔记","slug":"web笔记","permalink":"https://www.kassama.top/categories/web%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.kassama.top/tags/web/"},{"name":"HTML","slug":"HTML","permalink":"https://www.kassama.top/tags/HTML/"}]},{"title":"web学习笔记 - 颜色代码表","slug":"颜色代码表","date":"2020-03-25T09:48:30.000Z","updated":"2022-07-28T12:11:03.521Z","comments":true,"path":"/webNotes-ColorTable1.html","link":"","permalink":"https://www.kassama.top/webNotes-ColorTable1.html","excerpt":"记录一颜色代码表","text":"记录一颜色代码表 HTML及CSS常用颜色英文词汇 黑色 银色 灰色 白色 茶色 红色 紫色 紫红 black silver gray white maroon red purple fuchsia #000000 #C0C0C0 #808080 #FFFFFF #800000 #FF0000 #800080 #FF00FF 绿色 亮绿 橄榄 黄色 深蓝 蓝色 青色 浅绿 green lime olive yellow navy blue teal aqua #008000 #00FF00 #808000 #FFFF00 #000080 #0000FF #008080 #00FFFF CSS颜色代码大全 FFFFFF #DDDDDD #AAAAAA #888888 #666666 #444444 #000000 #FFB7DD #FF88C2 #FF44AA&nbsp; #FF0088&nbsp; #C10066&nbsp; #A20055&nbsp; #8C0044&nbsp; #FFCCCC #FF8888 #FF3333&nbsp; #FF0000&nbsp; #CC0000&nbsp; #AA0000&nbsp; #880000&nbsp; #FFC8B4 #FFA488 #FF7744&nbsp; #FF5511&nbsp; #E63F00&nbsp; #C63300&nbsp; #A42D00&nbsp; #FFDDAA #FFBB66 #FFAA33 #FF8800&nbsp; #EE7700&nbsp; #CC6600&nbsp; #BB5500&nbsp; #FFEE99 #FFDD55 #FFCC22 #FFBB00&nbsp; #DDAA00&nbsp; #AA7700&nbsp; #886600&nbsp; #FFFFBB #FFFF77 #FFFF33 #FFFF00 #EEEE00 #BBBB00 #888800 #EEFFBB #DDFF77 #CCFF33 #BBFF00 #99DD00 #88AA00 #668800 #CCFF99 #BBFF66 #99FF33 #77FF00 #66DD00 #55AA00 #227700 #99FF99 #66FF66 #33FF33 #00FF00 #00DD00 #00AA00 #008800 #BBFFEE #77FFCC #33FFAA #00FF99 #00DD77 #00AA55 #008844 #AAFFEE #77FFEE #33FFDD #00FFCC #00DDAA #00AA88 #008866 #99FFFF #66FFFF #33FFFF #00FFFF #00DDDD #00AAAA #008888 #CCEEFF #77DDFF #33CCFF #00BBFF #009FCC #0088A8 #007799 #CCDDFF #99BBFF #5599FF #0066FF&nbsp; #0044BB&nbsp; #003C9D&nbsp; #003377&nbsp; #CCCCFF #9999FF #5555FF&nbsp; #0000FF&nbsp; #0000CC&nbsp; #0000AA&nbsp; #000088&nbsp; #CCBBFF #9F88FF #7744FF&nbsp; #5500FF&nbsp; #4400CC&nbsp; #2200AA&nbsp; #220088&nbsp; #D1BBFF #B088FF #9955FF&nbsp; #7700FF&nbsp; #5500DD&nbsp; #4400B3&nbsp; #3A0088&nbsp; #E8CCFF #D28EFF #B94FFF&nbsp; #9900FF&nbsp; #7700BB&nbsp; #66009D&nbsp; #550088&nbsp; #F0BBFF #E38EFF #E93EFF&nbsp; #CC00FF&nbsp; #A500CC&nbsp; #7A0099&nbsp; #660077&nbsp; #FFB3FF #FF77FF #FF3EFF&nbsp; #FF0&nbsp;0FF&nbsp; #CC00CC&nbsp; #990099&nbsp; #770077&nbsp; 红色 颜色名称 代码 颜色 maroon #800000 darkred #8B0000 brown #A52A2A firebrick #B22222 crimson #DC143C red #FF0000 桃红 ~ 粉红 颜色名称 代码 颜色 mediumvioletred #C71585 palevioletred #D87093 deeppink #FF1493 fuchsia(magenta) #FF00FF hotpink #FF69B4 pink #FFC0CB lightpink #FFB6C1 mistyrose #FFE4E1 lavenderblush #FFF0F5 紫色 颜色名称 代码 颜色 indigo #4B0082 purple #800080 darkmagenta #8B008B darkorchid #9932CC blueviolet #8A2BE2 darkviolet #9400D3 slateblue #6A5ACD mediumpurple #9370DB mediumslateblue #7B68EE mediumorchid #BA55D3 violet #EE82EE plum #DDA0DD thistle #D8BFD8 lavender #E6E6FA 褐 ~ 橘 ~ 米白 颜色名称 代码 颜色 saddlebrown #8B4513 sienna #A0522D chocolate #D2691E indianred #CD5C5C rosybrown #BC8F8F lightcorol #F08080 salmon #FA8072 lightsalmon #FFA07A orangered #FF4500 tomato #FF6347 coral #FF7F50 darkorange #FF8C00 sandybrown #F4A460 peru #CD853F tan #D2B48C burlywood #DEB887 wheat #F5DEB3 moccasin #FFE4B5 navajowhite #FFDEAD peachpuff #FFDAB9 bisque #FFE4C4 antuquewhite #FAEBD7 papayawhip #FFEFD5 cornsilk #FFF8DC oldlace #FDF5E6 linen #FAF0E6 seashell #FFF5EE snow #FFFAFA floralwhite #FFFAF0 ivory #FFFFF0 mintcream #F5FFFA 金 ~ 黄 颜色名称 代码 颜色 darkgoldenrod #B8860B goldenrod #DAA520 gold #FFD700 yellow #FFFF00 darkkhaki #BDB76B khaki #F0E68C palegoldenrod #EEE8AA beige #F5F5DC lemonchiffon #FFFACD lightgoldenrodyellow #FAFAD2 lightyellow #FFFFE0 绿色 颜色名称 代码 颜色 darkslategray #2F4F4F darkolivegreen #556B2F olive #808000 darkgreen #006400 forestgreen #228B22 seagreen #2E8B57 green(teal) #008080 lightseagreen #20B2AA madiumaquamarine #66CDAA mediumseagreen #3CB371 darkseagreen #8FBC8F yellowgreen #9ACD32 limegreen #32CD32 lime #00FF00 chartreuse #7FFF00 lawngreen #7CFC00 greenyellow #ADFF2F mediumspringgreen #00FA9A springgreen #00FF7F lightgreen #90EE90 palegreen #98F898 aquamarine #7FFFD4 honeydew #F0FFF0 蓝色 颜色名称 代码 颜色 midnightblue #191970 navy #000080 darkblue #00008B darkslateblue #483D8B mediumblue #0000CD royalblue #4169E1 dodgerblue #1E90FF cornflowerblue #6495ED deepskyblue #00BFFF lightskyblue #87CEFA lightsteelblue #B0C4DE lightblue #ADD8E6 steelblue #4682B4 darkcyan #008B8B cadetblue #5F9EA0 darkturquoise #00CED1 mediumturquoise #48D1CC turquoise #40E0D0 skyblue #87CECB powderblue #B0E0E6 paleturquoise #AFEEEE lightcyan #E0FFFF azure #F0FFFF aliceblue #F0F8FF aqua(cyan) #00FFFF 黑 ~ 灰 ~ 白 颜色名称 代码 颜色 black #000000 dimgray #696969 gray #808080 slategray #708090 lightslategray #778899 dakgray #A9A9A9 silver #C0C0C0 lightgray #D3D3D3 gainsboro #DCDCDC whitesmoke #F5F5F5 ghostwhite #F8F8FF white #FFFFFF","categories":[{"name":"web笔记","slug":"web笔记","permalink":"https://www.kassama.top/categories/web%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.kassama.top/tags/web/"},{"name":"HTML","slug":"HTML","permalink":"https://www.kassama.top/tags/HTML/"}]},{"title":"web学习笔记2 - CSS基础","slug":"web学习笔记2","date":"2020-03-23T14:34:11.000Z","updated":"2022-09-19T12:55:37.703Z","comments":true,"path":"/webNotes2.html","link":"","permalink":"https://www.kassama.top/webNotes2.html","excerpt":"CSS基础 自学总结封面画师：唏嘘的星辰 p站ID：13312138","text":"CSS基础 自学总结封面画师：唏嘘的星辰 p站ID：13312138 盒子模型标准盒子计算公式：width=margin + border + padding + content 怪异盒子模型计算公式：width ：100px ，包含内边距 border + content 样式样式引入方式：行内样式 外联样式 内嵌样式，又称：行内元素，块元素，行内块元素 权重继承过来的样式优先级是最低的， 字体大小 字体颜色等标签名选择器优先级要低于类名选择器类名选择器优先级要低于id选择器id选择器优先级低于行内样式行内样式低于！important 权值!important : 最高行内样式 : 1000id : 100类 : 属性选择器 伪类选择器 10标签名 : 1继承过来 : 最低 权重优先级排序：!important &gt; 行内 &gt; id &gt; class &#x3D; 属性选择器 &gt; 标签名选择器 &gt; 继承过来的属性 选择器&gt; 父子关系~ 兄弟关系 后续的兄弟yuans+ 第一个兄弟元素[id=i1] 属性选择器nth-child() 父元素第几个子元素nth-of-type() 同种类型下第几个子元素 伪元素::before : 元素前::after : 元素后::first-line : 设置文本首行的特殊样式::first-letter : 设置文本首字母的特殊样式::selection : 选择器匹配元素中被用户选中或处于高亮状态的部分。::selection : 只可以应用于少数的CSS属性：color, background, cursor,和outline。 伪类:hover : 元素被选中:active : 元素被点击:visited : 设置访问过的页面链接的样式:focus : 选择元素输入后具有焦点 资源引入src 可以引入本地文件，也可以网络资源 &lt;img id=&quot;d1&quot; src=&quot;https://img2.baidu.com/it/u=3384430041,4206921743&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=640&amp;h=360&quot; alt=&quot;&quot;&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js&quot;&gt;&lt;/script&gt; 图片演示，下面js引入就不演示了（演示了没效果😂） 内容溢出word-breakkeep-all 不换行，但是会在空格符号和标点符号处进行换行break-all 可以在任何单词之间进行换行 overflowoverflow: hidden; 超出的部分直接剪切掉overflow: scroll; 超出部分出现滚动overflow-y: scroll; 指的是竖直方向上进行滚动overflow-x:scroll; 水平方向上超出滚动 精灵图片的作用精灵图 (雪碧图)：把多张小图设置一张大图片，可以减少图片的大小，在页面加载图片时候，只需要请求一次，减少了请求次数， transition &#x2F; animation 区别transitiontransition : 过渡动画，能够过渡的样式：与数字有关样式可以观察到过渡效果 直接设置过渡属性transition: all 2s linear;all : 能够过渡的样式都可以看到过渡效果2s : 过渡时间linear : 时间函数 速率匀速ease : 慢速开始，然后变快，然后慢速结束的过渡效果（等于cubic-bezier(0.25,0.1,0.25,1)）ease-in : 开始时候的慢ease-in-out : 开始结束的时候慢cubic-bezier(n,n,n,n) : 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。 分开设置过渡属性transition-property : 过渡属性transition-duration : 过渡时间transition-time-function : 过渡函数transition-delay : 延迟 animation #div1&#123; width: 200px; height: 200px; background-color: yellow; position: relative; left: 0; top: 0; /* 使用关键帧动画的样式 */ /* 动画名字 动画时间 动画速率 重复次数 infinite无限重复*/ animation: myAni 2s linear infinite; &#125; /* 定义关键帧动画 */ @keyframes myAni &#123; /* 0% 动画开始状态*/ from&#123; left: 0; top: 0; &#125; 50%&#123; left: 400px; top: 0; &#125; /* 100% 动画结束的状态*/ to&#123; left: 400px; top: 400px; &#125; &#125;","categories":[{"name":"web笔记","slug":"web笔记","permalink":"https://www.kassama.top/categories/web%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.kassama.top/tags/web/"},{"name":"HTML","slug":"HTML","permalink":"https://www.kassama.top/tags/HTML/"}]},{"title":"web学习笔记1 - html基础","slug":"web学习笔记1","date":"2020-03-20T13:32:30.000Z","updated":"2022-09-19T12:55:37.700Z","comments":true,"path":"/webNotes1.html","link":"","permalink":"https://www.kassama.top/webNotes1.html","excerpt":"html基础 自学总结封面画师：唏嘘的星辰 p站ID：13312138","text":"html基础 自学总结封面画师：唏嘘的星辰 p站ID：13312138 前端技术概括： HTML&#x2F;CSS JavaScript 各种脚本库，如：jQuery Node.js 各种框架，如：Vue, React, 小程序、uniapp web应用开发流程（仅作了解） 合理安排人员(项目经理，产品经理、UI设计师（美工），后端，前端，测试人员) 沟通了解需求（角色一般是产品经理或项目经理，主要了解做什么，谁做，何时做，为什么做的问题） 需求分析（角色一般是项目经理，解决怎样做，成本工期效率等问题） 项目设计（角色一般是UI设计师和后端，UI设计师进行界面设计，后端进行数据库设计） 项目开发（使用各种工具开始动手编码） 项目测试（测试人员使用各种测试工具测试代码，发现BUG，提交给开发人员） 运行维护（开发人员根据测试结果，维护代码，真至项目完美） 详细文档：https://www.cnblogs.com/ceshi2016/p/9212749.html 浏览器从输入URL到渲染完页面过程: DNS解析URL的过程 把IP地址解析成容易记忆的域名。 如：220.181.38.150 -&gt; www.baidu.com 浏览器与服务器交互过程 浏览器通过三次握手和服务器进行交互 浏览器页面渲染过程 当html被加载到浏览器中，解析html构建dom tree，通过link解析css，构建render tree。把这俩个组合在一起，渲染出看到的页面 参考文档:https://www.cnblogs.com/qing-5/p/11126524.html 语义化标签： html5建议程序员多去使用语义化标签，有助于seo搜索引擎进行搜索，但是目前语义花标签不太普及 语义化标签： main 内容区域 address 地址 footer 页尾 video 视频 audio 音频 strong 加粗 b 加粗 i 倾斜 del 删除 sub 下标 sup 上标 语义化标签的作用: &lt;b&gt;加粗&lt;/b&gt; &lt;i&gt;倾斜&lt;/i&gt; &lt;span style=&quot;text-decoration: line-through;&quot;&gt;我是使用css实现的删除线！&lt;/span&gt; &lt;del&gt;语义化删除线&lt;/del&gt; 加粗倾斜我是使用css实现的删除线！语义化删除线 锚点 a进行页面内的跳转a实现页面内的跳转 通过a标签的href的属性设置对应的元素id，可以把对应的元素的显示页面上边点我回到语义化标签！ &lt;a href=&quot;#语义化标签：&quot;&gt;点我回到&lt;b style=&quot;color: #000&quot;&gt;语义化标签&lt;/b&gt;！&lt;/a&gt; From表单 form 表单 action属性：提交数据的目标一般是接口地址mehtod:提交的方式：get：获取服务器数据，post：提交数据到服务器。目前暂且作为了解 for属性 点击用户名 输入框获取焦点 autocomplete on 开启自动填充账号 ，off关闭 maxlength 输入最大长度 minlength 输入最小长度 name 会把name属性的内容提交到服务器，格式位 username&#x3D;xxxx，passwd&#x3D;xxxx &lt;label for=&quot;i1&quot;&gt;用户名&lt;/label&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; id=&quot;i1&quot; autocomplete=&quot;on&quot; maxlength=&quot;9&quot; minlength=&quot;1&quot; name=&quot;username&quot;&gt; &lt;label for=&quot;i2&quot;&gt;密码&lt;/label&gt; &lt;input type=&quot;password&quot; placeholder=&quot;请输入密码&quot; id=&quot;i2&quot; autocomplete=&quot;on&quot; maxlength=&quot;9&quot; minlength=&quot;1&quot; name=&quot;password&quot;&gt; 用户名 密码 From表单内部常用元素 多选 name属性证明多选是一组 &lt;input type=&quot;checkbox&quot; name=&quot;n1&quot;&gt; 打篮球 &lt;input type=&quot;checkbox&quot; name=&quot;n1&quot;&gt; 敲代码 &lt;input type=&quot;checkbox&quot; name=&quot;n1&quot;&gt; 写代码 打篮球 敲代码 写代码 下拉菜单 美化select value属性可以省掉，默认值值option的内容 &lt;select name=&quot;n2&quot; id=&quot;&quot;&gt; &lt;option&gt;河南&lt;/option&gt; &lt;option&gt;河北&lt;/option&gt; &lt;option&gt;山西&lt;/option&gt; &lt;/select&gt; 河南 河北 山西 optgroup 分组 label分组名 &lt;select name=&quot;n3&quot; id=&quot;&quot;&gt; &lt;optgroup label=&quot;河南&quot;&gt; &lt;option value=&quot;1&quot;&gt;郑州&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;开封&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;洛阳&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label=&quot;河北&quot;&gt; &lt;option&gt;唐山&lt;/option&gt; &lt;option &gt;北京&lt;/option&gt; &lt;option &gt;天津&lt;/option&gt; &lt;/optgroup&gt; &lt;/select&gt; 郑州 开封 洛阳 唐山 北京 天津 单选框 name属性代表 相同name是一个小组，用在多选或者单选 &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;女 男 女 普通按钮没有提交功能 页面不会刷新 &lt;input type=&quot;button&quot; value=&quot;按钮&quot;&gt; 提交按钮默认有提交功能 点击提交按钮页面会刷新 &lt;input type=&quot;submit&quot; value=&quot;提交按钮&quot;&gt; 提交到服务器 提交到服务器 重置按钮 把输入框的输入内容清空掉 &lt;input type=&quot;reset&quot; value=&quot;重置按钮&quot;&gt; disabled 禁止标签可用 &lt;button disabled&gt;普通按钮&lt;/button&gt; 普通按钮 提交按钮 &lt;button type=&quot;submit&quot;&gt;提交按钮&lt;/button&gt; 提交按钮 重置按钮 &lt;button type=&quot;reset&quot;&gt;重置按钮&lt;/button&gt; 重置按钮 表格 table 表格 (一般使用在后台管理系统项目类型上 建议大家尽量不要使用table)tr 代表 行td 代表 单元格 &lt;table&gt; &lt;tr&gt; &lt;!-- colspan 合并列 --&gt; &lt;!-- rowspan 合并行 --&gt; &lt;td rowspan&#x3D;&quot;3&quot;&gt;第1项&lt;&#x2F;td&gt; &lt;td&gt;第2项&lt;&#x2F;td&gt; &lt;td rowspan&#x3D;&quot;2&quot;&gt;第3项&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;!-- &lt;td&gt;第1项&lt;&#x2F;td&gt; --&gt; &lt;td&gt;第2项&lt;&#x2F;td&gt; &lt;!-- &lt;td&gt;第3项&lt;&#x2F;td&gt; --&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;!-- &lt;td&gt;第1项&lt;&#x2F;td&gt; --&gt; &lt;td colspan&#x3D;&quot;2&quot;&gt;第2项&lt;&#x2F;td&gt; &lt;!-- &lt;td&gt;第3项&lt;&#x2F;td&gt; --&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt; 第1项 第2项 第3项 第2项 第2项 老的表格写法 ： thead 表头 th：表头标题加粗效果 以下特殊的标签不能加其他子元素 比如 table下只能加tr tr下只能加td，ul下只能li &lt;table&gt; &lt;thead&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 姓名 年龄 张三 18 张三 18 边框倒三角#d2&#123; border: 1px solid red; width: 100px; height: 100px; /* 网页的安全区域：顶宽居中 */ margin: 200px auto; border-top-width: 0px; border-right: none; /* 变换 rotate旋转 deg度 如果正值旋转顺时针 ，负值逆时针 */ transform: rotate(135deg); &#125; #d3&#123; /* 倒三角 1 设置 width heigh 为 0 2 设置4个方向上的边框的宽度 3 把其他三个方向上边框设置成透明颜色，只留一个边框的颜色 */ width: 0; height: 0; border: 10px solid; border-color: transparent transparent red transparent; &#125; 效果： 定位relative相对定位 自身的位置 absolute绝对定位 以他非静态定位祖先元素为参照， fixed固定定位 参照物以html为参照物的 static静态定位 不设置定位默认的就是静态定位 sticky粘性定位 滚动一定位置之后 再去固定位置，样式是属于一个新的样式，部分浏览器兼容性不好，需要时直接用js写 z-codeingE 元素名称(div, p); E#id 使用id的元素(div#content, p#intro, span#error); E.class 使用类的元素(div.header, p.error.critial). 你也可以联合使用class和idID: div#content.column.width; E&gt;N 子代元素(div&gt;p, div#footer&gt;p&gt;span); E+N 兄弟元素(h1+p, div#header+div#content+div#footer); E*N 元素倍增(ul#nav&gt;li*5&gt;a); E$*N 条目编号 (ul#nav&gt;li.item-$*5); 符号关系： &gt; 父子关系 + 兄弟关系 $ 是顺序 {} 表示内容 . 类 # id 用法：table&gt;tr*3&gt;td{第$项}*3","categories":[{"name":"web笔记","slug":"web笔记","permalink":"https://www.kassama.top/categories/web%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.kassama.top/tags/web/"},{"name":"HTML","slug":"HTML","permalink":"https://www.kassama.top/tags/HTML/"}]},{"title":"咔斯娱乐机器人娱乐使用及购买协议","slug":"宠物养成买前必读协议使用协议","date":"2020-03-15T17:30:06.000Z","updated":"2022-07-21T15:46:21.728Z","comments":true,"path":"/buypet.html","link":"","permalink":"https://www.kassama.top/buypet.html","excerpt":"请阁下认真阅读。","text":"请阁下认真阅读。 一旦你使用宠物养成的免费以及收费应用，请查看以下协议，且您必须遵循此协议！首先感谢您使用咔斯娱乐的宠物养成应用。本协议适用于本咔斯娱乐的所有收费、免费应用，如有特殊情况会另行通知。 本协议是您（或称”用户”）与咔斯娱乐之间使用咔斯娱乐制作的应用软件服务所订立的契约。在注册和登录本应用前，请您仔细阅读本协议的全部内容，特别是协议中以加粗字体显示的内容，您应重点阅读。如您对协议有任何疑问，可向咔斯娱乐提问。如果您不同意本协议或其中任何条款约定，请您立即停止注册和登录；您成功注册和登录后，本协议即构成对双方有约束力的法律文件。 收费应用购买协议 购买应用即代表你已经了解且知道此应用的名称和作用，并且愿意接受收费应用提供的教学服务。 用户在完成注册或登录程序实际使用本应用提供服务时，应当是具备完全民事权利能力和完全民事行为能力的自然人、法人或其他组织。若用户不具备前述主体资格，则用户及用户的监护人应当依照法律规定承担因此而导致的一切后果，官方有权注销或永久冻结您的账户。 由于电脑应用程序的可复制性，用户一旦付费购买应用以后，咔斯娱乐不接受任何理由的退款申请。 使用本应用禁止用于违法违规用途，禁止使用本应用暴力、反动、赌博、诈骗、淫秽色情等有害信息，咔斯娱乐不对用户的类似使用行为负责。 对于用户在使用或售后过程中出现不当言论、行为等，或在论坛、QQ群、QQ私聊等平台有故意诋毁咔斯娱乐任何人员和应用的，咔斯娱乐有权暂停或终止售后服务。 用户在使用咔斯娱乐所有的应用时可能会遇到软件报错，崩溃等情况，或出现漏洞、缺陷等问题，用户应该及时提交，并且详细描述（附带全屏录屏或全屏截图），若确实是咔斯娱乐的应用的题，我们将会及时处理。若经过核实此问题并不是咔斯娱乐的应用出现的，群主和管理员在给出明确的答复后即可。 所有用户未经允许，禁止私自将本人与咔斯娱乐群、咔斯娱乐群人员的任何交流记录，包括文字、图片、视频、表情包、文件等通过转发、截屏、上传等方式发布到论坛、其他QQ群、QQ空间等社交平台。 如应用涨价，已经购买的用户不受影响也无需补差价，但在新的价格公布以后想要购买的用户须按照现行价格。 如应用降价，已经购买的用户不受影响也无法申请退差价，但在新的价格公布以后想要购买的用户须按照现行价格。 如遇不可抗力导致的数据丢失、授权失效等非正常情况，咔斯娱乐会尽力恢复，但不保证。 *应用异常崩溃情况说明1. 残留进程导致的崩溃（这种情况是极少数的，存在几率很少）2. 你挂机器人的虚拟机系统不完整（一般出现情况为影子系统导致的）3. 你的机器上存在调试器类型的软件正在运行（请关闭调试器类型的软件即可正常打开）4. 网络不通畅导致的授权连接不稳定（可挂在稳定的云服务器上即可正常使用，推荐：腾讯云学生机、华为云学生机） 用户应当自行妥善保管自己在本应用的账号、密码等个人信息，避免使用过于简单的密码。您在服务使用过程中可以根据本应用规定更改密码。非经本应用事先同意，账号和密码不得出借、转让、继承或者赠与。非因本应用原因导致您的账号、密码遗失、遗忘或被他人窃取的，本应用不承担责任。如果您发现自己的个人信息泄密，尤其是本应用账户及密码发生泄露，请您立即和咔斯娱乐反馈。 用户只能在本应用和内容提供者授权下才能使用由本应用享有权利的内容，且无权擅自复制、修改这些内容，或创造与内容有关的派生产品。任何对本应用享有的基于该信息及&#x2F;或其载体，及&#x2F;或其表现形式，及&#x2F;或服务的权利的侵犯，均属于对本应用权利的侵犯。 收费应用违反执行协议 若用户未遵守本协议的，须对自己在网上的言论和行为承担法律责任，且咔斯娱乐有权作出独立判断并采取暂停或关闭用户帐号服务等措施。 咔斯娱乐会对违反协议的用户造成的影响进行判断，视情节轻重包括但不限于以下处理办法： 不再提供任何售后帮助服务但保留用户的应用授权和后期更新权利。 不再提供任何售后帮助服务。 封禁应用授权7天~永久不等。 向公安机关提交投诉。 免费应用使用协议 也请遵从以上收费应用的使用协议。 免费应用为完全免费使用，官方有权不提供任何售后服务，如遇到问题请自行解决（如遇到崩溃问题请查看收费应用购买协议的第十一条） 关于本协议的修改咔斯娱乐有权根据法律法规变化和实际运营需要，对本协议不定时地进行修改。本协议一旦发生变动，咔斯娱乐将通告用户，修改后的协议一经通告即生效。用户如果不同意所改动的内容，应主动停止使用咔斯娱乐提供的软件、服务。如果用户继续享用咔斯娱乐提供的软件、服务，则视为接受本协议的变动。一切以最新版本的协议为准。 用户与咔斯娱乐一致同意（以上所有条款）（1）双方应持平等、友好、争取合理解决问题的态度；（2）发生纠纷时首先以协商方式解决，如协商未果，任何一方可向相关社区管理部门反应。","categories":[{"name":"公告","slug":"公告","permalink":"https://www.kassama.top/categories/%E5%85%AC%E5%91%8A/"}],"tags":[{"name":"咔斯娱乐","slug":"咔斯娱乐","permalink":"https://www.kassama.top/tags/%E5%92%94%E6%96%AF%E5%A8%B1%E4%B9%90/"},{"name":"服务条款","slug":"服务条款","permalink":"https://www.kassama.top/tags/%E6%9C%8D%E5%8A%A1%E6%9D%A1%E6%AC%BE/"}]},{"title":"欢迎呀！咔斯的博客正式开启啦！","slug":"hello-world","date":"2020-02-11T04:39:45.000Z","updated":"2022-04-08T08:31:45.672Z","comments":false,"path":"2020/02/11/hello-world/","link":"","permalink":"https://www.kassama.top/2020/02/11/hello-world/","excerpt":"","text":"2020年2月11日，咔斯的博客搭建完毕！","categories":[{"name":"日志","slug":"日志","permalink":"https://www.kassama.top/categories/%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"QWQ","slug":"QWQ","permalink":"https://www.kassama.top/tags/QWQ/"},{"name":"博客","slug":"博客","permalink":"https://www.kassama.top/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"咔斯","slug":"咔斯","permalink":"https://www.kassama.top/tags/%E5%92%94%E6%96%AF/"}]}],"categories":[{"name":"web笔记","slug":"web笔记","permalink":"https://www.kassama.top/categories/web%E7%AC%94%E8%AE%B0/"},{"name":"日志","slug":"日志","permalink":"https://www.kassama.top/categories/%E6%97%A5%E5%BF%97/"},{"name":"wiki","slug":"wiki","permalink":"https://www.kassama.top/categories/wiki/"},{"name":"公告","slug":"公告","permalink":"https://www.kassama.top/categories/%E5%85%AC%E5%91%8A/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.kassama.top/tags/web/"},{"name":"HTML","slug":"HTML","permalink":"https://www.kassama.top/tags/HTML/"},{"name":"CDN","slug":"CDN","permalink":"https://www.kassama.top/tags/CDN/"},{"name":"wiki","slug":"wiki","permalink":"https://www.kassama.top/tags/wiki/"},{"name":"宠物养成","slug":"宠物养成","permalink":"https://www.kassama.top/tags/%E5%AE%A0%E7%89%A9%E5%85%BB%E6%88%90/"},{"name":"Vue","slug":"Vue","permalink":"https://www.kassama.top/tags/Vue/"},{"name":"咔斯娱乐","slug":"咔斯娱乐","permalink":"https://www.kassama.top/tags/%E5%92%94%E6%96%AF%E5%A8%B1%E4%B9%90/"},{"name":"服务条款","slug":"服务条款","permalink":"https://www.kassama.top/tags/%E6%9C%8D%E5%8A%A1%E6%9D%A1%E6%AC%BE/"},{"name":"QWQ","slug":"QWQ","permalink":"https://www.kassama.top/tags/QWQ/"},{"name":"博客","slug":"博客","permalink":"https://www.kassama.top/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"咔斯","slug":"咔斯","permalink":"https://www.kassama.top/tags/%E5%92%94%E6%96%AF/"}]}